/* ======================= COMPLETE RIG KIT MODULE (RESTRUCTURED) ======================= */

const RK_RDEF_LABELS = [
  'Rig model', 'Aperture (mm)', 'Central obstruction (mm)', 'Effective aperture area (mm²)', 
  'Effective focal length (mm)', 'Latitude (degrees [N+ / S-])', 'Longitude (degrees [E+ / W-])', 
  'Elevation above sea level (m)', 'Timezone UTC', 'DST start (MM-DD-YY)', 'DST end (MM-DD-YY)'
];

const RK_DFS_LABELS = [
  'Darkness convention',
  'Times reported based on...',
  'Object visibility reported as...',
  'Display objects observable for the next... (months)',
  'Display objects with a minimum observable time of... (minutes)',
  'Display objects between declinations... (degrees)'
];

const RK_IMC_LABELS = [
  'Maximum integration time per object (hours)', 'Maximum subframe exposure (minutes)', 'Minimum object elevation (degrees)',
  'Lunar avoidance angle (degrees)', 'Expected ambient temp (°C)', 'Sky Brightness (either Bortle Class or mag/arcsec^2)', 'Air quality index'
];

const RK_RDEF_START_ROW = 4;
const RK_COLOR_ROW = 16;
const RK_DFS_START_ROW = 18;
const RK_IMC_START_ROW = 27;
const RK_CRASH_CONE_START_ROW = 35;
const RK_HORIZON_HDR_ROW = 40;

function buildRigKit_(ss) {
  const sh = ss.getSheetByName('Rig kit') || ss.insertSheet('Rig kit', 2);
  sh.clear(); sh.setName('Rig kit');
  sh.clearConditionalFormatRules();

  sh.setColumnWidth(1, 200).setColumnWidths(2, sh.getMaxColumns() - 1, 45);
  sh.setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);
  sh.setRowHeight(RK_COLOR_ROW, 36);

  // Rig Definition Labels (rows 4-14)
  RK_RDEF_LABELS.forEach((t, i) => {
    const cell = leftLabel_(sh.getRange(RK_RDEF_START_ROW + i, 1)).setValue(t).setWrap(true);
    if (i === 0) cell.setWrap(true);
  });

  // Acknowledge Defaults row (Row 15)
  leftLabel_(sh.getRange(15, 1)).setValue('Acknowledge Defaults').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Rig Highlight Color row (Row 16)
  leftLabel_(sh.getRange(RK_COLOR_ROW, 1)).setValue('Rig Highlight Color').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Safe merge function
  const RK_safeFullWidthMerge = (row) => {
    try {
      const width = Math.max(3, RK_getActiveWidth_(sh) || 3);
      const range = sh.getRange(row, 1, 1, width);
      range.breakApart();
      range.merge();
    } catch (e) {
      console.log(`Merge warning for row ${row}: ${e.message}`);
    }
  };

  // Merge headers and section rows safely (including blank rows 17, 25, 39)
  [1, 2, 17, 18, 25, 26, 34, RK_CRASH_CONE_START_ROW, 39, RK_HORIZON_HDR_ROW].forEach(RK_safeFullWidthMerge);

  // Set section content
  sh.getRange(1, 1).setValue('Rig Kit');
  sh.getRange(17, 1).setValue(''); // blank
  sh.getRange(18, 1).setValue('Display Content');
  sh.getRange(25, 1).setValue(''); // blank
  sh.getRange(26, 1).setValue('Imaging Constraints');
  sh.getRange(34, 1).setValue('');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setValue('Zenith Obstruction');
  sh.getRange(39, 1).setValue(''); // blank
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setValue('Landscape Horizon');

  // DISPLAY CONTENT LABELS (rows 19-24)
  RK_DFS_LABELS.forEach((label, i) => {
    const row = RK_DFS_START_ROW + 1 + i;
    const cell = leftLabel_(sh.getRange(row, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Choose between Astronomical and Nautical twilight for darkness calculations'); break;
      case 1: cell.setNote('Base timing calculations on object transit or rising times'); break;
      case 2: cell.setNote('Report visibility windows as general visibility or optimal imaging conditions'); break;
      case 3: cell.setNote('Set forecast period for object visibility planning'); break;
      case 4: cell.setNote('Minimum continuous observation time required for an object to be included'); break;
      case 5: cell.setNote('Declination range limits for object visibility at your location'); break;
    }
  });

  // IMAGING CONSTRAINTS LABELS (rows 27-33)
  RK_IMC_LABELS.forEach((label, i) => {
    const cell = leftLabel_(sh.getRange(RK_IMC_START_ROW + i, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Total time allocated for imaging this target across all sessions'); break;
      case 1: cell.setNote('Maximum exposure time per individual subframe to avoid trailing or saturation'); break;
      case 2: cell.setNote('Minimum altitude above horizon required for acceptable image quality'); break;
      case 3: cell.setNote('Angular distance from moon required to avoid interference'); break;
      case 4: cell.setNote('Expected ambient temperature for sensor cooling calculations'); break;
      case 5: cell.setNote('Local sky darkness rating affecting signal-to-noise ratio'); break;
      case 6: cell.setNote('Atmospheric transparency measurement affecting image quality'); break;
    }
  });

  // Zenith obstruction labels with note (A35)
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 1, 1)).setValue('Leg 1');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 2, 1)).setValue('Leg 2');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 3, 1)).setValue('Leg 3');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setNote('Define zenith obstruction cone using three azimuth/altitude coordinate pairs');
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setNote('Define landscape horizon profile using azimuth/altitude coordinate pairs for terrain masking');

  const addRigCell = sh.getRange('A3');
  addRigCell.setDataValidation(
  SpreadsheetApp.newDataValidation()
    .requireValueInList(['Add Rig', 'Add Duplicate', 'Cancel'], true)
    .setAllowInvalid(true)
    .build()
  );
  addRigCell.setValue('Add Rig...');
  sh.getRange('B3').setValue('Rig 1');
  sh.getRange('B4:C34').setHorizontalAlignment('center').setVerticalAlignment('middle');

  RK_applyRigPairMerges_(sh, 2);

  // Merge rows 22 and 23 for all rig pairs at build
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL, cR]) => {
  try {
    sh.getRange(22, cL, 1, 2).merge();
    sh.getRange(23, cL, 1, 2).merge();
    } catch (e) {}
  });
  
  sh.setRowHeights(RK_CRASH_CONE_START_ROW + 1, 3, 36);
  sh.setRowHeight(RK_HORIZON_HDR_ROW, 36);
  sh.setRowHeights(RK_HORIZON_HDR_ROW + 1, 101, 36);

  RK_applyRigPairValidations_(sh, 2);
  RK_setupColorPickers_(sh);
  RK_setDefaultValues_(sh);
  RK_setupRigHelpers_(sh);
  RK_setupAcknowledgeDefaults_(sh);

  sh.setFrozenRows(3);
  recolorRigKitBands_(sh);
  enforceRigFormats_();
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function RK_getActiveWidth_(sh) {
  let width = 1;
  let c = 2;
  while (c <= sh.getMaxColumns()) {
    const headerValue = sh.getRange(3, c).getDisplayValue().trim();
    if (headerValue && headerValue.match(/^Rig\s+\d+$/)) {
      width = c + 1;
      c += 2;
    } else {
      break;
    }
  }
  return width;
}

function recolorRigKitBands_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = RK_getActiveWidth_(sh);
  const borderColor = hpcShade(hpc, 40);

  const title = sh.getRange(1, 1, 1, width).merge();
  title.setValue('Rig Kit').setBackground(hpcShade(hpc, 80)).setFontSize(16).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);

  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setBackground(addBg).setFontSize(12).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle');
  stylePaddedCell_(addCell, 'Add Rig...', addBg, '#FFFFFF', true);

  if (width > 1) {
    const rigHeaders = sh.getRange(3, 2, 1, width - 1);
    rigHeaders.setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle');
  }

  const subheaderRows = [2, 18, 26, RK_CRASH_CONE_START_ROW, RK_HORIZON_HDR_ROW];
  subheaderRows.forEach(row => {
    const subheader = sh.getRange(row, 1, 1, width);
    subheader.setBackground(hpcShade(hpc, 30)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  });

  // Blank rows: 17, 25, 34, 39
  [17, 25, 34, 39].forEach(row => {
    const blankRange = sh.getRange(row, 1, 1, width).merge();
    blankRange.setValue('').setBackground(null);
  });

  for (let row = 36; row <= 38; row++) {
    sh.getRange(row, 1).setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('right').setVerticalAlignment('middle');
  }

  sh.getRange(1, 1, sh.getFrozenRows(), width).setBorder(true, true, true, true, null, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sh.getRange('A4:A15').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A16:A16').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A19:A24').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange('A27:A33').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  RK_paintAllDataCellsOrange_(sh);
}

function RK_paintAllDataCellsOrange_(sh) {
  const width = RK_getActiveWidth_(sh);
  if (width <= 1) return;
  // Removed row 7 (calculated), removed row 15 (acknowledge defaults checkbox)
  const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
  dataRowRanges.forEach(([startRow, endRow]) => {
    const range = sh.getRange(startRow, 2, endRow - startRow + 1, width - 1);
    range.setBackground(WARN_ORANGE);
  });
}

function RK_applyRigPairMerges_(sh, cL) {
  const rowsToMerge = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 19, 20, 21];
  rowsToMerge.forEach(r => {
    try { sh.getRange(r, cL, 1, 2).breakApart(); sh.getRange(r, cL, 1, 2).merge(); } catch (e) {}
  });
  for (let r = 27; r <= 33; r++) {
    try { sh.getRange(r, cL, 1, 2).breakApart(); sh.getRange(r, cL, 1, 2).merge(); } catch (e) {}
  }
}

function RK_applyRigPairValidations_(sh, cL) {
  try {
    const setupSheet = SpreadsheetApp.getActive().getSheetByName('Setup');
    const defaults = setupSheet ? setupSheet.getRange('C4:C9').getValues().flat() : [null, null, null, null, null, null];
    const dvNum = (a, b) => SpreadsheetApp.newDataValidation().requireNumberBetween(a, b).setAllowInvalid(true).build();
    const dvDate = SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build();

    sh.getRange(4, cL, 1, 2).setWrap(true);
    
    // Row 5: Aperture (10-2000)
    sh.getRange(5, cL, 1, 2).setDataValidation(dvNum(10, 2000));
    
    // Row 6: Central obstruction (0-200)
    sh.getRange(6, cL, 1, 2).setDataValidation(dvNum(0, 200));

    // Row 7: Effective aperture area - FORMULA ONLY, not editable
    const areaCell = sh.getRange(7, cL, 1, 2);
    if (!areaCell.getValue()) {
      const apertureCell = sh.getRange(5, cL);
      const obstructionCell = sh.getRange(6, cL);
      const areaFormula = `=PI()*(${apertureCell.getA1Notation()}/2)^2-PI()*(${obstructionCell.getA1Notation()}/2)^2`;
      areaCell.setFormula(areaFormula).setNumberFormat('0.00');
    }
    areaCell.setBackground('#f3f3f3').setFontColor('#666666');
    const protection = areaCell.protect().setDescription('Calculated field');
    protection.setWarningOnly(true);
    
    // Row 8: Effective focal length (50-10000)
    sh.getRange(8, cL, 1, 2).setDataValidation(dvNum(50, 10000));

    // Row 9-14: Location data with defaults
    const finderDv = SpreadsheetApp.newDataValidation().requireValueInList(['Retrieve 4D Location', 'Cancel']).setAllowInvalid(true).build();
    const latRng = sh.getRange(9, cL, 1, 2);
    const lonRng = sh.getRange(10, cL, 1, 2);
    const elvRng = sh.getRange(11, cL, 1, 2);
    const utcRng = sh.getRange(12, cL, 1, 2);
    const dstStartRng = sh.getRange(13, cL, 1, 2);
    const dstEndRng = sh.getRange(14, cL, 1, 2);

    if (!latRng.getValue()) latRng.setValue(defaults[0]).setBackground(WARN_ORANGE);
    if (!lonRng.getValue()) lonRng.setValue(defaults[1]).setBackground(WARN_ORANGE);
    if (!elvRng.getValue()) elvRng.setValue(defaults[3]).setBackground(WARN_ORANGE);
    if (!utcRng.getValue()) utcRng.setValue(defaults[2]).setBackground(WARN_ORANGE);
    if (!dstStartRng.getValue()) dstStartRng.setValue(defaults[4]).setBackground(WARN_ORANGE);
    if (!dstEndRng.getValue()) dstEndRng.setValue(defaults[5]).setBackground(WARN_ORANGE);

    latRng.setDataValidation(finderDv).setWrap(true);
    lonRng.setDataValidation(dvNum(-180, 180)).setNumberFormat('0.0000');
    elvRng.setDataValidation(dvNum(-100, 5000)).setNumberFormat('0');
    utcRng.setDataValidation(dvNum(-12, 12));
    dstStartRng.setDataValidation(dvDate).setNumberFormat('MM-dd-yy');
    dstEndRng.setDataValidation(dvDate).setNumberFormat('MM-dd-yy');

    // Display format dropdowns
    sh.getRange(19, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Astro', 'Nautical'], true).setAllowInvalid(true).build());
    sh.getRange(20, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Transit', 'Rising'], true).setAllowInvalid(true).build());
    sh.getRange(21, cL, 1, 2).setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Visible', 'Optimum'], true).setAllowInvalid(true).build());
    
    // Row 22: Observable months (1-12)
    sh.getRange(22, cL, 1, 2).setDataValidation(dvNum(1, 12));
    
    // Row 23: Minimum observable time (10-480)
    sh.getRange(23, cL, 1, 2).setDataValidation(dvNum(10, 480));
    
    // Row 24: Declination limits (-90 to +90) - NOT merged, separate cells
    sh.getRange(24, cL).setDataValidation(dvNum(-90, 90));
    sh.getRange(24, cL + 1).setDataValidation(dvNum(-90, 90));
    
    // Row 27: Max integration time (blank or 1-9999)
    sh.getRange(27, cL, 1, 2).setDataValidation(dvNum(0, 9999));
    
    // Row 28: Max subframe exposure (blank or 1-999)
    sh.getRange(28, cL, 1, 2).setDataValidation(dvNum(0, 999));
    
    // Row 29: Min object elevation (blank or 1-80)
    sh.getRange(29, cL, 1, 2).setDataValidation(dvNum(0, 80));
    
    // Row 30: Lunar avoidance (blank or 1-90)
    sh.getRange(30, cL, 1, 2).setDataValidation(dvNum(0, 90));
    
    // Row 31: Ambient temp (-50 to +50)
    sh.getRange(31, cL, 1, 2).setDataValidation(dvNum(-50, 50));
    
    // Row 32: Sky Brightness (1.0-9.0 for Bortle, 14.0-25.0 for mag/arcsec²)
    // Using custom validation that allows decimals in both ranges
    const skyBrightnessFormula = '=OR(AND(B32>=1,B32<=9),AND(B32>=14,B32<=25))';
    sh.getRange(32, cL, 1, 2).setDataValidation(
      SpreadsheetApp.newDataValidation()
        .requireNumberBetween(1, 25)
        .setAllowInvalid(false)
        .setHelpText('Enter Bortle Class (1.0-9.0) or magnitude per square arcsecond (14.0-25.0)')
        .build()
    );
    
    // Row 33: Air quality (blank or 0-200) - allow web retrieval to override
    sh.getRange(33, cL, 1, 2).setDataValidation(dvNum(0, 200));
    
    // Rows 36-38: Zenith obstruction (Az: 0-360, Alt: 0-90)
    for (let r = 36; r <= 38; r++) {
      sh.getRange(r, cL).setDataValidation(dvNum(0, 360));
      sh.getRange(r, cL + 1).setDataValidation(dvNum(0, 90));
    }
    
    // Set data validation warning colors (paint yellow on invalid entry)
    const validationRanges = [
      [5, cL, 1, 2], [6, cL, 1, 2], [8, cL, 1, 2],
      [9, cL, 1, 2], [10, cL, 1, 2], [11, cL, 1, 2], [12, cL, 1, 2],
      [22, cL, 1, 2], [23, cL, 1, 2], [24, cL], [24, cL + 1],
      [27, cL, 1, 2], [28, cL, 1, 2], [29, cL, 1, 2], [30, cL, 1, 2],
      [31, cL, 1, 2], [32, cL, 1, 2], [33, cL, 1, 2]
    ];
    validationRanges.forEach(coords => {
      const range = coords.length === 4 ? sh.getRange(coords[0], coords[1], coords[2], coords[3]) : sh.getRange(coords[0], coords[1]);
      range.setDataValidation(range.getDataValidation().copy().setAllowInvalid(true).build());
    });
    
  } catch (e) {
    console.log('Validation error:', e.message);
  }
}

function RK_setupColorPickers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
    const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    
    pairs.forEach(([cL, cR]) => {
      const cell = sh.getRange(16, cL, 1, 2);
      try { 
        cell.breakApart(); 
        cell.merge(); 
        cell.setDataValidation(dv); 
        cell.setHorizontalAlignment('center').setVerticalAlignment('middle');
        // Set default to Blue color (not just HPC), clear text
        const blueHex = nameToHex_('Blue') || getHPC_Global_();
        cell.setBackground(blueHex).setValue('');
      } catch (e) {}
    });
  } catch (e) {}
}

function RK_setDefaultValues_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      // Row 22: Default 3 months
      if (!sh.getRange(22, cL, 1, 2).getValue()) {
        sh.getRange(22, cL, 1, 2).setValue(3).setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // Row 23: Default 60 minutes
      if (!sh.getRange(23, cL, 1, 2).getValue()) {
        sh.getRange(23, cL, 1, 2).setValue(60).setBackground(WARN_ORANGE).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
    });
  } catch (e) {}
}

function RK_setupAcknowledgeDefaults_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      const cell = sh.getRange(15, cL, 1, 2);
      try { cell.breakApart(); cell.merge(); cell.insertCheckboxes(); cell.setHorizontalAlignment('center').setVerticalAlignment('middle'); } catch (e) {}
    });
  } catch (e) {}
}

function RK_setupRigHelpers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    try {
      const width = RK_getActiveWidth_(sh) || 3;
      sh.getRange(24, 2, 1, width - 1).breakApart();
      for (let c = 2; c <= width; c += 2) {
        if (c + 1 <= sh.getMaxColumns()) {
          sh.getRange(24, c).setValue("> Dec").setHorizontalAlignment('center');
          sh.getRange(24, c + 1).setValue("< Dec").setHorizontalAlignment('center');
        }
      }
    } catch (e) {}
    const RK_CRASH_CONE_START_ROW = 35;
    pairs.forEach(([cL, cR]) => {
      for (let i = 0; i < 3; i++) {
        const row = RK_CRASH_CONE_START_ROW + 1 + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
        sh.getRange(row, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
    });
    const RK_HORIZON_HDR_ROW = 40;
    pairs.forEach(([cL, cR]) => {
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL).setValue('Az');
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cR).setValue('Alt');
      sh.getRange(RK_HORIZON_HDR_ROW + 2, cL).setValue('');
      sh.getRange(RK_HORIZON_HDR_ROW + 2, cR).setValue('');
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  } catch (e) {}
}

function enforceRigFormats_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  try {
    getPairsFromHeaders_(sh).forEach(([cL]) => {
      sh.getRange(7,  cL, 1, 2).setNumberFormat('#,##0');   // Row 7: Effective aperture area
      sh.getRange(9,  cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(10, cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(11, cL, 1, 2).setNumberFormat('0');        // Row 11: UTC Offset
      sh.getRange(12, cL, 1, 2).setNumberFormat('0');        // Row 12: Elevation
      sh.getRange(13, cL, 1, 2).setNumberFormat('MM-dd-yy');
      sh.getRange(14, cL, 1, 2).setNumberFormat('MM-dd-yy');
    });
  } catch (e) {}
}

function SkyPix_AddRig_(duplicatePrevious) {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  try {
    const setupSheet = SpreadsheetApp.getActive().getSheetByName('Setup');
    const lastCol = sh.getLastColumn();
    sh.insertColumnsAfter(lastCol, 2);
    const newCol = lastCol + 1;
    const rigNumber = Math.floor((newCol - 1) / 2);

    // Merge Rig Kit title row across all columns
    sh.getRange(1, 1, 1, sh.getLastColumn()).breakApart().merge();

    // Set header with HPC styling
    const hpc = getHPC_Global_();
    sh.getRange(3, newCol, 1, 2).merge()
      .setValue(`Rig ${rigNumber}`)
      .setBackground(hpcShade(hpc, 40))
      .setFontSize(12)
      .setFontWeight('bold')
      .setFontColor('#FFFFFF')
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle');

    // Merge all needed rows for new rig (except 24, 36, 37, 38)
    const mergeRows = [
      4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,39,40
    ];
    mergeRows.forEach(row => {
      if (![24,36,37,38].includes(row)) {
        try { sh.getRange(row, newCol, 1, 2).merge(); } catch(e){}
      }
    });

    // Merge section headers (for banding)
    [2, 17, 18, 25, 26, 34, 35, 39, 40].forEach(row => {
      try {
        const range = sh.getRange(row, 1, 1, newCol + 1);
        range.breakApart();
        range.merge();
      } catch (e) {}
    });

    // --- DUPLICATE LOGIC ---
    if (duplicatePrevious && lastCol >= 2) {
      for (let r = 4; r <= 50; r++) {
        if (r === 15 || r === 16) continue;
        // Copy strictly row-to-row
        const prevVals = sh.getRange(r, lastCol - 1, 1, 2).getValues();
        sh.getRange(r, newCol, 1, 2).setValues(prevVals);
      }
      // Copy Zenith Obstruction (36-38, unmerged)
      for (let row = 36; row <= 38; row++) {
        const vals = sh.getRange(row, lastCol - 1, 1, 2).getValues();
        sh.getRange(row, newCol, 1, 2).breakApart().setValues(vals);
      }
      // Copy Horizon (41 - last nonblank), unmerged
      let lastHorizonRow = 50;
      for (let row = 50; row <= sh.getMaxRows(); row++) {
        const leftVal = sh.getRange(row, lastCol - 1).getValue();
        const rightVal = sh.getRange(row, lastCol).getValue();
        if (leftVal !== "" || rightVal !== "") lastHorizonRow = row;
      }
      for (let row = 41; row <= lastHorizonRow; row++) {
        const vals = sh.getRange(row, lastCol - 1, 1, 2).getValues();
        sh.getRange(row, newCol, 1, 2).breakApart().setValues(vals);
        sh.getRange(row, newCol, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // Copy row 24 (do not merge)
      const vals24 = sh.getRange(24, lastCol - 1, 1, 2).getValues();
      sh.getRange(24, newCol, 1, 2).breakApart().setValues(vals24);
    } else {
      // --- Standard New Rig (not duplicate) ---
      // Paint all relevant rows orange except row 16 (color picker)
      const dataRowRanges = [[4, 6], [8, 14], [19, 24], [27, 33], [36, 38], [41, 50]];
      dataRowRanges.forEach(([startRow, endRow]) => {
        sh.getRange(startRow, newCol, endRow - startRow + 1, 2)
          .setBackground(WARN_ORANGE)
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
      });
      // Helper text for row 24
      sh.getRange(24, newCol).breakApart().setValue("> Dec").setHorizontalAlignment('center').setVerticalAlignment('middle');
      sh.getRange(24, newCol + 1).breakApart().setValue("< Dec").setHorizontalAlignment('center').setVerticalAlignment('middle');
      // Zenith helpers for new rig ONLY
      for (let i = 0; i < 3; i++) {
        const row = 36 + i;
        sh.getRange(row, newCol).breakApart().setValue('Az').setHorizontalAlignment('center').setVerticalAlignment('middle');
        sh.getRange(row, newCol + 1).breakApart().setValue('Alt').setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // Horizon helpers for new rig ONLY (row 41)
      sh.getRange(41, newCol).breakApart().setValue('Az').setHorizontalAlignment('center').setVerticalAlignment('middle');
      sh.getRange(41, newCol + 1).breakApart().setValue('Alt').setHorizontalAlignment('center').setVerticalAlignment('middle');
      // Center all horizon rows
      for (let r = 41; r <= 50; r++) {
        sh.getRange(r, newCol, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // --- Setup mapping for rows 9-14 ---
      // Please check Setup sheet row mapping for your actual use; this is a generic example:
      // Setup: 4-lat, 5-lon, 6-Elevation, 7-Timezone, 8-DST start, 9-DST end
      if (setupSheet) {
        sh.getRange(9, newCol, 1, 2).setValue(setupSheet.getRange(4, 3).getValue());  // latitude
        sh.getRange(10, newCol, 1, 2).setValue(setupSheet.getRange(5, 3).getValue()); // longitude
        sh.getRange(11, newCol, 1, 2).setValue(setupSheet.getRange(6, 3).getValue()); // Elevation
        sh.getRange(12, newCol, 1, 2).setValue(setupSheet.getRange(7, 3).getValue()); // Timezone
        sh.getRange(13, newCol, 1, 2).setValue(setupSheet.getRange(8, 3).getValue()); // DST start
        sh.getRange(14, newCol, 1, 2).setValue(setupSheet.getRange(9, 3).getValue()); // DST end
      }
    }

    // Always merge 15 & 16 for the new rig pair
    [15, 16].forEach(row => {
      try { sh.getRange(row, newCol, 1, 2).merge(); } catch(e){}
    });

    // Color picker for row 16, always blue by default
    const colorNames = ['Blue', 'Deep Blue', 'Steel Blue', 'Cyan', 'Light Blue', 'Cornflower', 'Green', 'Teal', 'Purple', 'Magenta', 'Red', 'Red Berry', 'Maroon', 'Brown', 'Slate', 'Navy', 'Dk Green'];
    const colorMap = {
      "Blue": "#1E90FF", "Deep Blue": "#00008B", "Steel Blue": "#4682B4", "Cyan": "#00FFFF",
      "Light Blue": "#ADD8E6", "Cornflower": "#6495ED", "Green": "#228B22", "Teal": "#008080",
      "Purple": "#800080", "Magenta": "#FF00FF", "Red": "#FF0000", "Red Berry": "#b22234",
      "Maroon": "#800000", "Brown": "#A52A2A", "Slate": "#708090", "Navy": "#000080", "Dk Green": "#006400"
    };
    const colorDV = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    sh.getRange(16, newCol, 1, 2)
      .setDataValidation(colorDV)
      .setBackground(colorMap["Blue"])
      .setValue('');

    // Acknowledge Defaults checkbox
    sh.getRange(15, newCol, 1, 2)
      .insertCheckboxes()
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle');

    // Defaults for rows 22 and 23
    sh.getRange(22, newCol, 1, 2).setValue(3).setHorizontalAlignment('center').setVerticalAlignment('middle');
    sh.getRange(23, newCol, 1, 2).setValue(60).setHorizontalAlignment('center').setVerticalAlignment('middle');

    // --- Row 7 formula and protection ---
    function getColLetter(colNum) {
      let temp = '';
      let letter = '';
      while (colNum > 0) {
        temp = (colNum - 1) % 26;
        letter = String.fromCharCode(temp + 65) + letter;
        colNum = (colNum - temp - 1) / 26;
      }
      return letter;
    }
    const apertureCol = getColLetter(newCol);
    const obstructionCol = getColLetter(newCol + 1);
    const formula = `=PI()*(${apertureCol}5/2)^2-PI()*(${obstructionCol}6/2)^2`;
    sh.getRange(7, newCol).setFormula(formula);
    sh.getRange(7, newCol + 1).setFormula(formula);
    sh.getRange(7, newCol, 1, 2)
      .setNote('Editing not allowed. Value is calculated.')
      .setDataValidation(
        SpreadsheetApp.newDataValidation()
          .requireTextEqualTo('') // Only allow blank (will always warn)
          .setAllowInvalid(true)
          .setHelpText('Editing not allowed. Value is calculated.')
          .build()
      );

    // Expand dynamic blank rows to include new rig
    if (typeof RK_expandBlankRows_ === "function") RK_expandBlankRows_(sh);

    // Re-merge section headers (for banding)
    [2, 17, 18, 25, 26, 34, 35, 39, 40].forEach(row => {
      try {
        const range = sh.getRange(row, 1, 1, newCol + 1);
        range.breakApart();
        range.merge();
      } catch (e) {}
    });

    SpreadsheetApp.getActive().toast(`Rig ${rigNumber} added successfully.`);
  } catch (e) {
    SpreadsheetApp.getActive().toast('Error adding rig: ' + e.message);
  }

  // Always re-apply merges and validation fixes for all rigs
  if (typeof rigkit_mergeRows2223_ === "function") rigkit_mergeRows2223_();
  if (typeof rigkit_fixRow32Validation_ === "function") rigkit_fixRow32Validation_();
  if (typeof rigkit_fixColorPicker_ === "function") rigkit_fixColorPicker_();
  if (typeof rigkit_paintBlanksYellow_ === "function") rigkit_paintBlanksYellow_();

  // Merge rows 22-23 for the new rig as a patch
  try {
    const patchCol = sh.getLastColumn() - 1;
    sh.getRange(22, patchCol, 1, 2).merge();
    sh.getRange(23, patchCol, 1, 2).merge();
  } catch (e) {}

  // Ensure color picker is valid and blue for the new rig
  try {
    const patchCol = sh.getLastColumn() - 1;
    sh.getRange(16, patchCol, 1, 2)
      .setDataValidation(
        SpreadsheetApp.newDataValidation().requireValueInList(
          ['Blue', 'Red', 'Green', 'Purple', 'Slate', 'Red Berry', 'Navy', 'Dk Green'], true
        ).setAllowInvalid(true).build()
      )
      .setBackground("#1E90FF")
      .setValue('');
  } catch (e) {}

  // --- Always reset A3 after add
  sh.getRange('A3').setValue('');
  SpreadsheetApp.flush();
  sh.getRange('A3').setValue('Add Rig...');
}

function RK_expandBlankRows_(sh) {
  const width = RK_getActiveWidth_(sh);
  [17, 25, 34, 39].forEach(row => {
    try { 
      const range = sh.getRange(row, 1, 1, width); 
      range.breakApart(); 
      range.merge();
      range.setValue('').setBackground(null);
    } catch (e) {}
  });
}

function RK_updateAllRigHelpers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      sh.getRange(24, cL).setValue("> Dec").setHorizontalAlignment('center');
      sh.getRange(24, cR).setValue("< Dec").setHorizontalAlignment('center');
    });
    const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
    const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    const hpc = getHPC_Global_();
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(16, cL, 1, 2); 
      cell.setDataValidation(dv); 
      cell.setBackground(hpc).setValue('');
    });
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(15, cL, 1, 2); 
      try { 
        cell.breakApart(); 
        cell.merge(); 
        cell.insertCheckboxes(); 
        cell.setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } catch (e) {} 
    });
    const RK_CRASH_CONE_START_ROW = 35;
    pairs.forEach(([cL, cR]) => { 
      for (let i = 0; i < 3; i++) { 
        const row = RK_CRASH_CONE_START_ROW + 1 + i; 
        sh.getRange(row, cL).setValue('Az'); 
        sh.getRange(row, cR).setValue('Alt'); 
        sh.getRange(row, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } 
    });
    const RK_HORIZON_HDR_ROW = 40;
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL).setValue('Az'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cR).setValue('Alt'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
    });
    const finderDv = SpreadsheetApp.newDataValidation().requireValueInList(['Retrieve 4D Location', 'Cancel']).setAllowInvalid(true).build();
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(9, cL, 1, 2).setDataValidation(finderDv); 
    });
    RK_setDefaultValues_(sh);
  } catch (e) {}
}

function RK_handleAcknowledgeDefaults_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  if (row !== 15 || col < 2) return;
  const isChecked = e.range.getValue();
  if (isChecked !== true) return;
  
  try {
    // Find which rig pair (column pair) this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (!targetPair) return;
    
    const [cL, cR] = targetPair;
    
    // Data rows that should be cleared of orange if filled
    const dataRowRanges = [[4, 6], [8, 14], [16, 16], [27, 33], [36, 38]];
    
    // Critical rows that must have values - paint yellow if blank
    const criticalRanges = [
      [5, 6], [8, 12], [19, 24], [41, 44]
    ];
    
    // Clear orange from filled cells
    dataRowRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        const cell = sh.getRange(r, cL, 1, 2);
        const bg = cell.getBackground();
        const val = cell.getValue();
        
        if (bg && bg.toLowerCase() === WARN_ORANGE.toLowerCase()) {
          cell.setBackground(null);
        }
      }
    });
    
    // Paint critical blank cells yellow
    criticalRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        // Check merged cell value
        const cell = sh.getRange(r, cL, 1, 2);
        const val = String(cell.getValue() || '').trim();
        
        // For row 41-44, check individual cells too for "Az"
        if (r >= 41 && r <= 44) {
          const leftVal = String(sh.getRange(r, cL).getValue() || '').trim();
          const rightVal = String(sh.getRange(r, cL + 1).getValue() || '').trim();
          if (!leftVal || leftVal === 'Az') {
            sh.getRange(r, cL).setBackground(WARN_YELLOW);
          }
          if (!rightVal || rightVal === 'Alt') {
            sh.getRange(r, cL + 1).setBackground(WARN_YELLOW);
          }
        } else {
          // For merged cells, check if empty
          if (!val) {
            cell.setBackground(WARN_YELLOW);
          }
        }
      }
    });
    
  } catch (error) {
    console.log('Acknowledge Defaults processing error:', error.message);
  }
}

function RK_handleCellEdit_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  
  // Handle color picker (row 16) - paint cell and CLEAR text immediately
  if (row === 16 && col >= 2) {
    const colorName = String(e.value || '').trim();
    if (colorName && colorName !== '') {
      const hex = nameToHex_(colorName);
      if (hex) {
        e.range.setBackground(hex);
        e.range.setValue('');
        e.range.setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
        return;
      }
    }
  }
  
  // Handle Acknowledge Defaults checkbox (row 15)
  if (row === 15 && col >= 2 && e.value === true) {
    // Find which rig pair this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (targetPair) {
      const [cL, cR] = targetPair;
      
      // Clear orange/yellow from ALL data rows in this rig's column pair
      const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
      
      dataRowRanges.forEach(([startRow, endRow]) => {
        for (let r = startRow; r <= endRow; r++) {
          const cell = sh.getRange(r, cL, 1, 2);
          const bg = cell.getBackground();
          if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
            cell.setBackground(null);
          }
        }
      });
    }
    return;
  }
  
  // Smart unpaint: clear orange/yellow on user edit in data ranges
  const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
  const isInDataRange = dataRowRanges.some(([start, end]) => row >= start && row <= end);
  if (isInDataRange && col >= 2) {
    const bg = e.range.getBackground();
    if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
      e.range.setBackground(null);
    }
  }
  
  // Preserve 4D location finder dropdown after use
  if (row === 9 && col >= 2) {
    const finderDv = SpreadsheetApp.newDataValidation()
      .requireValueInList(['Retrieve 4D Location', 'Cancel'])
      .setAllowInvalid(true)
      .build();
    e.range.setDataValidation(finderDv);
  }
}

function getLandHdrRow_(sh) {
  let row = findRowWithText_(sh, 'Landscape Horizon');
  if (row) return row;
  const afterZenith = findRowWithText_(sh, 'Zenith Obstruction');
  const insertAt = (afterZenith ? afterZenith + 2 : Math.max(1, sh.getLastRow()) + 2);
  sh.insertRows(insertAt, 3);
  sh.getRange(insertAt, 1, 1, 3).merge().setValue('Landscape Horizon').setHorizontalAlignment('left').setVerticalAlignment('middle');
  sh.getRange(insertAt + 1, 2).setValue('Az');
  sh.getRange(insertAt + 1, 3).setValue('Alt');
  return insertAt;
}

function rigkit_mergeSectionHeader_(sh, headerRow) {
  if (!sh || !headerRow) return;
  const width = Math.max(2, (typeof getActiveWidth_ === 'function' ? getActiveWidth_(sh) : sh.getMaxColumns()));
  try { sh.getRange(headerRow, 1, 1, width).merge(); } catch (e) {}
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }
  const colorRow = 16;
  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation().requireValueInList(names, true).setAllowInvalid(true).build();
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });
  ss.toast('Rig color picker restored.');
}

function _rigkit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const text = cell.getDisplayValue();
    if (text && text.match(/^Rig\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  const cameraSheet = ss.getSheetByName('Camera Kit');
  if (cameraSheet) {
    rebuildRigEligibility_Camera_Fixed_(cameraSheet, rigs);
    recolorCameraKitBands_(cameraSheet);
  }
  const filterSheet = ss.getSheetByName('Filter Kit');
  if (filterSheet) {
    rebuildRigEligibility_Filter_Fixed_(filterSheet, rigs);
    recolorFilterKitBands_(filterSheet);
  }
  SpreadsheetApp.getActive().toast('Camera Kit and Filter Kit refreshed from Rig kit.');
}

function _rigkit_getRigSpecs_(rigSh) {
  const blocks = _rigkit_getBlocks_(rigSh);
  const nameRow = 3;
  const colorRow = 16;
  const flRow = findRowWithText_(rigSh, 'Effective focal length');
  const rigs = [];
  blocks.forEach(b => {
    const name = rigSh.getRange(nameRow, b.startCol).getDisplayValue().trim();
    if (!name || /^add rig/i.test(name)) return;
    let color = '';
    if (colorRow) {
      const colorCell = rigSh.getRange(colorRow, b.startCol);
      const bgColor = colorCell.getBackground();
      const textValue = colorCell.getDisplayValue().trim();
      if (bgColor && bgColor !== '#ffffff' && bgColor !== '#FFFFFF') {
        color = bgColor;
      } else if (textValue) {
        color = nameToHex_(textValue) || textValue;
      }
      if (!color) color = getHPC_Global_();
    }
    const fl = flRow ? Number(rigSh.getRange(flRow, b.startCol).getDisplayValue()) : NaN;
    rigs.push({ name, color, focalLengthMM: fl });
  });
  return rigs;
}

function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rebuildRigEligibility_Camera_Fixed_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  let eligHeader = findRowWithText_(camSh, 'Rig Eligibility');
  if (!eligHeader) {
    const lastDataRow = Math.max(15, camSh.getLastRow());
    camSh.insertRowsAfter(lastDataRow, 1);
    eligHeader = lastDataRow + 1;
    mergeFullWidthRow_(camSh, eligHeader);
    camSh.getRange(eligHeader, 1).setValue('Rig Eligibility').setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
  const startRow = eligHeader + 1;
  const clearRows = Math.max(rigs.length * 3, 20);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width).clearContent().removeCheckboxes().setBackground(null).setFontWeight('normal').setFontColor('#000000');
  }
  const cameraBlocks = _camerakit_getBlocks_(camSh);
  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';
    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View (arcminutes)').setFontWeight('normal');
    camSh.getRange(scaleRow, 1).setValue('Image Scale (arcsec/pixel)').setFontWeight('normal');
    camSh.getRange(checkboxRow, 1, 3, width).setBackground(shadedColor).setFontColor(fontColor);
    cameraBlocks.forEach(block => {
      camSh.getRange(checkboxRow, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
      camSh.getRange(fovRow, block.startCol, 1, block.width).merge().setValue('0').setHorizontalAlignment('center').setVerticalAlignment('middle');
      camSh.getRange(scaleRow, block.startCol, 1, block.width).merge().setValue('0').setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  });
}

function rebuildRigEligibility_Filter_Fixed_(filterSh, rigs) {
  if (!filterSh || !rigs || !rigs.length) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(filterSh);
  let eligHeader = findRowWithText_(filterSh, 'Rig Eligibility');
  if (!eligHeader) {
    const ackRow = findRowWithText_(filterSh, 'Acknowledge Defaults');
    if (ackRow) {
      filterSh.insertRowsAfter(ackRow, 2);
      eligHeader = ackRow + 2;
      mergeFullWidthRow_(filterSh, eligHeader);
      filterSh.getRange(eligHeader, 1).setValue('Rig Eligibility').setBackground(hpcShade(hpc, 40)).setFontSize(12).setFontWeight('bold').setFontColor(DARK_GREY_FONT).setHorizontalAlignment('center').setVerticalAlignment('middle');
    }
  }
  if (!eligHeader) return;
  const startRow = eligHeader + 1;
  const clearRows = Math.max(rigs.length + 5, 10);
  if (startRow + clearRows <= filterSh.getMaxRows()) {
    filterSh.getRange(startRow, 1, clearRows, width).clearContent().removeCheckboxes().setBackground(null).setFontWeight('normal').setFontColor('#000000');
  }
  const filterBlocks = getFilterBlocks_(filterSh);
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';
    leftLabel_(filterSh.getRange(row, 1)).setValue(rig.name);
    filterSh.getRange(row, 1, 1, width).setBackground(shadedColor).setFontColor(fontColor);
    filterBlocks.forEach(block => {
      filterSh.getRange(row, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center').setVerticalAlignment('middle');
    });
  });
}

function updateAllRigAirQuality() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;
  const airQualityRow = findRowWithText_(sh, 'Air quality index');
  if (!airQualityRow) return;
  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    if (lat && lon) {
      try {
        const aqi = getAirQualityIndex(lat, lon);
        if (aqi !== null) { sh.getRange(airQualityRow, cL, 1, 2).setValue(aqi); }
      } catch (e) { console.log(`Air quality lookup failed for rig at ${lat}, ${lon}: ${e.message}`); }
    }
  });
  SpreadsheetApp.getActive().toast('Air quality data updated for all rigs');
}

function updateAllRigBortleClass() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;
  const skyBrightnessRow = findRowWithText_(sh, 'Sky Brightness');
  if (!skyBrightnessRow) return;
  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    if (lat && lon) {
      try {
        const bortle = getBortleClass(lat, lon);
        if (bortle !== null) { sh.getRange(skyBrightnessRow, cL, 1, 2).setValue(bortle); }
      } catch (e) { console.log(`Bortle class lookup failed for rig at ${lat}, ${lon}: ${e.message}`); }
    }
  });
  SpreadsheetApp.getActive().toast('Sky brightness data updated for all rigs');
}

function getAirQualityIndex(lat, lon) {
  const { airNowApiKey } = getSkyPixConfig();
  if (!airNowApiKey) return null;
  try {
    const url = `https://www.airnowapi.org/aq/observation/latLong/current/?format=application/json&latitude=${lat}&longitude=${lon}&distance=50&API_KEY=${airNowApiKey}`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const data = JSON.parse(response.getContentText());
    if (response.getResponseCode() === 200 && data.length > 0) { return data[0].AQI || null; }
  } catch (e) { console.log('Air quality API error:', e.message); }
  return null;
}

function getBortleClass(lat, lon) { return 'Class 4-5'; }

function rigkit_applyZenithLandscapeLayout_(sh) {
  if (!sh) return;
  const pairs = getPairsFromHeaders_(sh);
  let zenithRow = findRowWithText_(sh, 'Zenith Obstruction');
  if (zenithRow) {
    pairs.forEach(([cL, cR]) => {
      for (let i = 1; i <= 3; i++) {
        const row = zenithRow + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
      }
    });
  }
  let horizonRow = getLandHdrRow_(sh);
  if (horizonRow) {
    pairs.forEach(([cL, cR]) => {
      sh.getRange(horizonRow + 1, cL).setValue('Az');
      sh.getRange(horizonRow + 1, cR).setValue('Alt');
      for (let i = 2; i <= 10; i++) {
        sh.getRange(horizonRow + i, cL).setValue('');
        sh.getRange(horizonRow + i, cR).setValue('');
      }
    });
  }
}

function rebuildRigEligibility_Camera_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  const ck = ss.getSheetByName(CK.NAME);
  if (ck) rebuildRigEligibility_Camera_Fixed_(ck, rigs);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) rebuildRigEligibility_Filter_Fixed_(fk, rigs);
  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

function rebuildRigEligibility_Filter_() {
  const ss = SpreadsheetApp.getActive();
  const rigData = getRigData_();
  const filterBlocks = getFilterBlocks_(ss.getSheetByName(FK.NAME));
  rebuildRigEligibility_Filter_(rigData, filterBlocks);
}

// ======================= CAMERA KIT RIG ELIGIBILITY =======================

function rebuildCameraRigEligibility_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  
  let ackRow = findRowWithText_(camSh, 'Acknowledge Defaults');
  if (!ackRow) {
    const lastRow = Math.max(14, camSh.getLastRow());
    camSh.insertRowsAfter(lastRow, 1);
    ackRow = lastRow + 1;
    leftLabel_(camSh.getRange(ackRow, 1)).setValue('Acknowledge Defaults').setFontSize(10).setFontWeight('normal');
    if (width > 1) {
      camSh.getRange(ackRow, 2, 1, width - 1).merge().insertCheckboxes().setHorizontalAlignment('center');
    }
  }

  const blankRow = ackRow + 1;
  if (blankRow + 2 > camSh.getMaxRows()) {
    camSh.insertRowsAfter(camSh.getMaxRows(), 3);
  }
  mergeFullWidthRow_(camSh, blankRow);
  camSh.getRange(blankRow, 1).setValue('').setBackground(null);

  const eligHeader = blankRow + 1;
  mergeFullWidthRow_(camSh, eligHeader);
  camSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
        .setBackground(hpcShade(hpc, 40))
        .setFontSize(12)
        .setFontWeight('bold')
        .setFontColor(DARK_GREY_FONT)
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle');

  const startRow = eligHeader + 1;
  
  const clearRows = Math.max(rigs.length * 3, 15);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width)
        .clearContent()
        .removeCheckboxes()
        .setBackground(null)
        .setFontWeight('normal')
        .setFontColor('#000000');
  }

  const cameraBlocks = _camerakit_getBlocks_(camSh);

  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    
    camSh.setRowHeight(checkboxRow, 36);
    camSh.setRowHeight(fovRow, 36);
    camSh.setRowHeight(scaleRow, 36);
    
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 30);
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View\n(arcminutes)').setFontWeight('normal').setWrap(true).setHorizontalAlignment('right');
    camSh.getRange(scaleRow, 1).setValue('Image Scale\n(arcsec/pixel)').setFontWeight('normal').setWrap(true).setHorizontalAlignment('right');
    
    camSh.getRange(checkboxRow, 1, 3, width)
        .setBackground(shadedColor)
        .setFontColor(fontColor);

    cameraBlocks.forEach(block => {
      camSh.getRange(checkboxRow, block.startCol, 1, block.width)
          .merge()
          .insertCheckboxes()
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');

      camSh.getRange(fovRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('right')
          .setVerticalAlignment('middle')
          .setWrap(true);
          
      camSh.getRange(scaleRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('right')
          .setVerticalAlignment('middle')
          .setWrap(true);
    });
  });
}

function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

// ======================= FILTER KIT RIG ELIGIBILITY =======================

function rebuildFilterRigEligibility_(filterSh, rigs) {
  let startRow = 15;
  
  const maxRows = filterSh.getMaxRows();
  if (startRow < maxRows) {
    filterSh.deleteRows(startRow + 3, maxRows - startRow - 2);
  }
  
  leftLabel_(filterSh.getRange(startRow, 1)).setValue('Acknowledge Defaults');
  
  filterSh.getRange(startRow + 1, 1).setValue('').setBackground(hpcShade(getHPC_Global_(), 40));
  
  filterSh.getRange(startRow + 2, 1).setValue('Rig Eligibility').setBackground(hpcShade(getHPC_Global_(), 40));
  styleSubheader_(filterSh.getRange(startRow + 2, 1), DARK_GREY_FONT);
  
  let currentRow = startRow + 3;
  rigs.forEach(rig => {
    const rigRange = filterSh.getRange(currentRow, rig.column, 1, 2);
    rigRange.setBackground(hpcShade(rig.color, 30));
    rigRange.insertCheckboxes().setValue(false);
    rigRange.setVerticalAlignment('middle').setHorizontalAlignment('center');
    
    currentRow += 1;
  });
  
  rigs.forEach(rig => {
    filterSh.getRange(startRow, rig.column, 1, 2).insertCheckboxes().setValue(false);
  });
}

// ======================= AIR QUALITY AND BORTLE CLASS FUNCTIONS =======================

function updateAllRigAirQuality() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;

  const airQualityRow = findRowWithText_(sh, 'Air quality index');
  if (!airQualityRow) return;

  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    
    if (lat && lon) {
      try {
        const aqi = getAirQualityIndex(lat, lon);
        if (aqi !== null) {
          sh.getRange(airQualityRow, cL, 1, 2).setValue(aqi);
        }
      } catch (e) {
        console.log(`Air quality lookup failed for rig at ${lat}, ${lon}: ${e.message}`);
      }
    }
  });

  SpreadsheetApp.getActive().toast('Air quality data updated for all rigs');
}

function updateAllRigBortleClass() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  const pairs = getPairsFromHeaders_(sh);
  if (pairs.length === 0) return;

  const skyBrightnessRow = findRowWithText_(sh, 'Sky Brightness');
  if (!skyBrightnessRow) return;

  pairs.forEach(([cL, cR]) => {
    const lat = sh.getRange(9, cL).getValue();
    const lon = sh.getRange(10, cL).getValue();
    
    if (lat && lon) {
      try {
        const bortle = getBortleClass(lat, lon);
        if (bortle !== null) {
          sh.getRange(skyBrightnessRow, cL, 1, 2).setValue(bortle);
        }
      } catch (e) {
        console.log(`Bortle class lookup failed for rig at ${lat}, ${lon}: ${e.message}`);
      }
    }
  });

  SpreadsheetApp.getActive().toast('Sky brightness data updated for all rigs');
}

function getAirQualityIndex(lat, lon) {
  const { airNowApiKey } = getSkyPixConfig();
  if (!airNowApiKey) return null;
  
  try {
    const url = `https://www.airnowapi.org/aq/observation/latLong/current/?format=application/json&latitude=${lat}&longitude=${lon}&distance=50&API_KEY=${airNowApiKey}`;
    const response = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const data = JSON.parse(response.getContentText());
    
    if (response.getResponseCode() === 200 && data.length > 0) {
      return data[0].AQI || null;
    }
  } catch (e) {
    console.log('Air quality API error:', e.message);
  }
  
  return null;
}

function getBortleClass(lat, lon) {
  return 'Class 4-5'; // Suburban/Rural transition
}

function rigkit_applyZenithLandscapeLayout_(sh) {
  if (!sh) return;
  
  const width = getActiveWidth_(sh);
  const pairs = getPairsFromHeaders_(sh);
  
  let zenithRow = findRowWithText_(sh, 'Zenith Obstruction');
  if (zenithRow) {
    pairs.forEach(([cL, cR]) => {
      for (let i = 1; i <= 3; i++) {
        const row = zenithRow + i;
        sh.getRange(row, cL).setValue('Az');
        sh.getRange(row, cR).setValue('Alt');
      }
    });
  }
  
  let horizonRow = getLandHdrRow_(sh);
  if (horizonRow) {
    pairs.forEach(([cL, cR]) => {
      sh.getRange(horizonRow + 1, cL).setValue('Az');
      sh.getRange(horizonRow + 1, cR).setValue('Alt');
      for (let i = 2; i <= 10; i++) {
        sh.getRange(horizonRow + i, cL).setValue('');
        sh.getRange(horizonRow + i, cR).setValue('');
      }
    });
  }
}

function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function rebuildRigEligibility_Camera_() {
  const ss = SpreadsheetApp.getActive();
  rebuildRigEligibility_Camera_();
  rebuildRigEligibility_Filter_();

  const ck = ss.getSheetByName(CK.NAME);
  if (ck) recolorCameraKitBands_(ck);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) recolorFilterKitBands_(fk);

  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

function rebuildRigEligibility_Filter_() {
  const ss = SpreadsheetApp.getActive();
  
  const rigData = getRigData_();
  const filterBlocks = getFilterBlocks_(ss.getSheetByName(FK.NAME));
  rebuildRigEligibility_Filter_(rigData, filterBlocks);
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }

  const colorRow = findRowWithText_(sh, 'Rig highlight color');
  if (!colorRow) { SpreadsheetApp.getUi().alert('"Rig highlight color" row not found.'); return; }

  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(names, true)
    .setAllowInvalid(true)
    .build();

  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });

  ss.toast('Rig color picker restored.');
}

