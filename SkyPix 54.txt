/************************************************************
 * SkyPix Planner — Definitive Backend Code (Alpha 53)
 ************************************************************/
function clearTestApiKeys() {
  const properties = PropertiesService.getScriptProperties();
  properties.deleteProperty('CSE_KEY');
  properties.deleteProperty('CSE_CX'); 
  properties.deleteProperty('AIRNOW_KEY');
  Logger.log('Test keys cleared - users will need to enter their own');
}
function testSaveKeys() {
  try {
    const testKeys = {
      'CSE_KEY': 'test123',
      'CSE_CX': 'test456'
    };
    setApiKeys_(testKeys);
    Logger.log('Save test completed');
  } catch (e) {
    Logger.log('Save test failed: ' + e.message);
  }
}
// ======================= DEBUGGING UTILITY =======================
const IS_DEBUG_MODE = true;

function logDebug_(message) {
  if (IS_DEBUG_MODE) {
    Logger.log(message);
  }
}
function debugApiKeys() {
  const props = PropertiesService.getScriptProperties().getProperties();
  Logger.log('All stored properties:');
  for (const key in props) {
    Logger.log(key + ': ' + (props[key] ? props[key].substring(0, 10) + '...' : 'empty'));
  }
}
/* ======================= PUBLIC ENTRY ======================= */
/* ===== MENU-OPEN — START (safe) ===== */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  const menu = ui.createMenu('SkyPix Planner');

  menu.addItem('Build All', 'SkyPix_BuildAll');

  const buildSubMenu = ui.createMenu('Build Individual Sheets')
    .addItem('Build Object Entry', 'SkyPix_BuildObjectEntry')
    .addItem('Build Setup', 'SkyPix_BuildSetup')
    .addItem('Build Rig Kit', 'SkyPix_BuildRigKit')
    .addItem('Build Camera Kit', 'SkyPix_BuildCameraKit')
    .addItem('Build Filter Kit', 'SkyPix_BuildFilterKit')
    .addItem('Build Object Database', 'SkyPix_BuildObjectDatabase');
  menu.addSubMenu(buildSubMenu);

  const toolsSubMenu = ui.createMenu('Tools')
    .addItem('Find Location by Address...', 'showLocationFinder')
    .addItem('Add 25 Object Rows', 'SkyPix_AddObjects_')
    .addItem('Test Object Lookup (active row)', 'SkyPix_Debug_TestObjectFetch_');
  menu.addSubMenu(toolsSubMenu);

  const adminSubMenu = ui.createMenu('Admin')
    .addItem('Set API Keys...', 'showApiKeysDialog_')
    .addItem('Authorize Script (First-Time Use)', 'SkyPix_Authorize_')
    .addSeparator()
    .addItem('Set API Keys (Manual)', 'setApiKeysManually')
    .addItem('Enable onEdit Trigger', 'SkyPix_EnableOnEdit_')
    .addItem('!!! Delete All Sheets !!!', 'deleteAllSkyPixSheets_')
    .addItem('Resolve Pasted List…', 'showResolveProgress_')
    .addItem('Fix Zenith/Landscape layout', 'run_fix_zenith_landscape_')
    .addItem('Restore Rig color picker', 'rigkit_restoreColorPicker_')
    .addItem('Restore Location Finders', 'rigkit_restoreAllLocationFinders_');
  menu.addSubMenu(adminSubMenu);

  menu.addToUi();

  try { installOnEditTrigger_(); }
  catch (err) {
    SpreadsheetApp.getActive().toast('Note: onEdit trigger not installed. Use Admin ▸ Enable onEdit Trigger.');
  }
}

function run_fix_zenith_landscape_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (sh) rigkit_applyZenithLandscapeLayout_(sh);
}

/* ===== MENU-OPEN — END ===== */

// --- Bootstrap guard so early code can safely read FK.NAME even before FK is defined.
var FK = (typeof FK !== 'undefined') ? FK : { NAME: 'Filter Kit' };

// --- Bootstrap guard for Camera Kit (CK) to prevent early reference errors.
// This ensures CK has a minimal structure before the full definition loads later.
var CK = (typeof CK !== 'undefined') ? CK : {
  NAME: 'Camera Kit',
  ROWS: { COLOR: 13, ACK: 15 },
  BAND_ID_LABEL: 'Band ID'
};

function deleteAllSkyPixSheets_() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Are you sure you want to permanently delete all SkyPix Planner sheets?', ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) return;
  const ss = SpreadsheetApp.getActive();
  const sheetNamesToDelete = ['_config', 'Object Entry', 'Setup', 'Rig kit', CK.NAME, FK.NAME, 'Object Database', 'Setup Parameters', 'Sensor Kit'];
  sheetNamesToDelete.forEach(name => {
    const sheet = ss.getSheetByName(name);
    if (sheet) ss.deleteSheet(sheet);
  });
  ss.toast('All SkyPix Planner sheets have been deleted.');
}

function onEditTrigger(e) {
  const lock = LockService.getScriptLock();
  const hasLock = lock.tryLock(15000);
  if (!hasLock) return;
  try {
    if (!e || !e.range) {        // <— guard for manual runs
      Logger.log('onEditTrigger invoked without event; ignoring.');
      return;
    }
    logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
    SkyPix_DispatchOnChange_(e);
  } catch (err) {
    logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
  } finally {
    lock.releaseLock();
  }
  camerakit_handleColorPicker_(e);
}


function createOnEditTrigger_() {
  const ss = SpreadsheetApp.getActive();
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onEditTrigger') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  ScriptApp.newTrigger('onEditTrigger').forSpreadsheet(ss).onEdit().create();
}

function SkyPix_BuildAll() {
  const ss = SpreadsheetApp.getActive();
  _createConfigSheet_(ss);
  buildObjectEntrySheet_(ss);
  buildSetup_(ss);
  buildRigKit_(ss);
  buildCameraKit_(ss);
  buildFilterKit_(ss);
  buildObjectDatabase_(ss);
}

function SkyPix_Authorize_() {
  try {
    UrlFetchApp.fetch('https://www.google.com');
    PropertiesService.getScriptProperties().getKeys();
    SpreadsheetApp.getActive().toast('SkyPix Planner has been successfully authorized.');
  } catch (e) {
    SpreadsheetApp.getActive().toast('Authorization process initiated. Please review and allow permissions.');
  }
}
function SkyPix_EnableOnEdit_() {
  installOnEditTrigger_();
  SpreadsheetApp.getActive().toast('onEdit trigger enabled.');
}

/* ======================= ON EDIT DISPATCHER ======================= */
/* ===== DUPLICATE onEditTrigger (OLD) — commented out by dridge3771 2025-11-07 =====
   This duplicate definition was removed to prevent ReferenceErrors.
   The canonical onEditTrigger is defined earlier in the file (around line 113).

// function onEditTrigger(e) {
//   const scriptLock = LockService.getScriptLock();
//   const hasLock = scriptLock.tryLock(15000);
//   if (!hasLock) return;
//   try {
//     logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
//     SkyPix_DispatchOnChange_(e);
//   } catch (err) {
//     logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
//   } finally {
//     scriptLock.releaseLock();
//   }
// }

   ===== END DUPLICATE onEditTrigger ===== */


function SkyPix_DispatchOnChange_(e) {
  const sh = e.range.getSheet();
  const sheetName = sh.getName();
  const a1 = e.range.getA1Notation();
  const val = e.value;
  const oldVal = e.oldValue;
  const editRow = e.range.getRow();
  const editCol = e.range.getColumn();
  const label = sh.getRange(editRow, 1).getDisplayValue();

  // --- Universal Color Cell Handling ---
if (
  (sheetName === 'Setup' && (a1 === 'C12' || a1 === 'C13')) ||
  (sheetName === 'Rig kit' && label.includes('Rig highlight color')) ||
  (sheetName === CK?.NAME && editRow === CK?.ROWS?.COLOR && editCol > 1)
) {
    paintColorCell_(e.range, val);
    if (sheetName === 'Setup' && a1 === 'C12') {
      recolorAllSheets_();
    } else {
      if (typeof RK_handleCellEdit_ === "function") RK_handleCellEdit_(e);
    }
    return;
  }

  // --- Orange/Yellow warning clearing ---
  const bg = e.range.getBackground().toLowerCase();
  if (bg === WARN_ORANGE?.toLowerCase() || bg === WARN_YELLOW?.toLowerCase()) {
    if (isValueValid_(val, e.range)) {
      e.range.setBackground(null);
    }
  }
  Logger.log('=== ABOUT TO ENTER SWITCH - sheetName: "' + sheetName + '" ===');
// if (!(sheetName.endsWith('Kit') && a1 === 'A3')) return;

  // --- Setup Sheet Logic ---
  if (sheetName === 'Setup') {
    if (a1 === 'C4' && val === 'Retrieve 4D Location') {
      showLocationFinder('Setup');
      e.range.setValue('');
      return;
    }
    
    // Handle Refresh Rig Kit action
    if (editRow === 2 && val === 'Refresh Rig Kit') {
      propagateSetupToRigs_();
      styleRefreshBarNeutral_(sh);
      return;
    }
    
    // Capture OLD value and paint bar yellow for location data edits (C4-C9)
    if (editRow >= 4 && editRow <= 9 && editCol === 3) {
      // Skip color pickers (rows 12-13 in your new layout don't need this, but kept for safety)
      if (editRow === 12 || editRow === 13) return;
      
      // Store OLD value before it was changed
      const oldSetupVal = e.oldValue || '';
      const key = `SETUP_OLD_R${editRow}`;
      PropertiesService.getScriptProperties().setProperty(key, String(oldSetupVal));
      
      // Only paint yellow if value actually changed
      if (oldSetupVal !== val) {
        setRefreshBarYellow_(sh);
      }
      return;
    }
    
    // Acknowledge Defaults checkbox (C21)
    if (a1 === 'C21' && val === 'TRUE') {
      sh.getRange('C18:C20').setBackground(null);
    }
    
    return;
  }

  // --- Sheet-Case Switch ---
  switch (sheetName) {
    // --- Object Entry Sheet ---
    case 'Object Entry':
      if (editCol === 1 && editRow > 4 && val) {
        const rng = e.range;
        if (rng.getNumRows() > 1 || rng.getNumColumns() > 1) {
          showResolveProgress_();
          return;
        }
        const out = fetchSimbadData(rng);
        if (out === 'Success') setRefreshBarYellow_(sh);
        return;
      }
      if (editRow === 2 && val === 'Refresh Database') {
        processObjectEntries_();
        styleRefreshBarNeutral_(sh);
        writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_DB_ONLY);
        return;
      }
      if (editRow === 2 && val === 'Update Database') {
        processObjectEntries_();
        rigkit_resetRefreshBar_(sh);
        return;
      }
      break;

    // --- Rig Kit Sheet ---
    case 'Rig kit':
      // Row 15: "Acknowledge Defaults" checkbox logic
      if (editRow === 15) {
        if (val === "TRUE") {
          RK_acknowledgeDefaults_(sh, editCol);
        }
        return;
      }
      // Row 16: "Rig Highlight Color" picker logic
      if (editRow === 16 && val) {
        if (typeof RK_handleColorPicker_ === "function") RK_handleColorPicker_(sh, editCol, val);
        return;
      }

      // Handle Add Rig / Add Duplicate / Cancel in the dropdown at A3
      if (a1 === 'A3') {
        if (val === 'Add Rig') {
          SkyPix_AddRig_();
          return;
        }
        if (val === 'Add Duplicate') {
          SkyPix_AddRig_(true);
          return;
        }
        if (val === 'Cancel') {
          sh.getRange('A3').setValue('Add Rig...');
          return;
        }
        sh.getRange('A3').setValue('');
        SpreadsheetApp.flush();
        sh.getRange('A3').setValue('Add Rig...');
      }

      // Refresh actions and planner glue
      if (editRow === 2) {
        if (val === 'Refresh Kits') {
          if (typeof refreshKits_ === "function") refreshKits_();
          if (typeof rigkit_resetRefreshBar_ === "function") rigkit_resetRefreshBar_(sh);
          return;
        }
        if (val === 'Refresh Air Quality Index') {
          if (typeof updateAllRigAirQuality === "function") updateAllRigAirQuality();
          if (typeof rigkit_resetRefreshBar_ === "function") rigkit_resetRefreshBar_(sh);
          return;
        }
        if (val === 'Refresh Bortle Class') {
          if (typeof updateAllRigBortleClass === "function") updateAllRigBortleClass();
          if (typeof rigkit_resetRefreshBar_ === "function") rigkit_resetRefreshBar_(sh);
          return;
        }
        if (val === 'Refresh Planner') {
          // Optionally: planner update glue
          if (typeof rigkit_resetRefreshBar_ === "function") rigkit_resetRefreshBar_(sh);
          return;
        }
      }

      if (editRow === 9 && val === 'Retrieve 4D Location') {
        showLocationFinder('Rig kit', e.range.getA1Notation());
        e.range.setValue('');
        return;
      }
      // Rig deletion logic
      if (editRow === 3 && (!val || val.trim() === '')) {
        const ui = SpreadsheetApp.getUi();
        const response = ui.alert(`Are you sure you want to delete rig "${oldVal}"?`, ui.ButtonSet.YES_NO);
        if (response == ui.Button.YES) {
          sh.deleteColumns(editCol, 2);
        } else {
          e.range.setValue(oldVal);
        }
        return;
      }
      // Rig name change logic
      if (editRow === 3 && val !== oldVal) {
        if (typeof rigkit_forceColorPicker_ === "function") rigkit_forceColorPicker_();
        if (typeof rigkit_resetRefreshBar_ === "function") rigkit_resetRefreshBar_(sh);
        return;
      }
      if (editRow === 23) {
        if (typeof rebuildRigEligibility_Camera_ === "function") rebuildRigEligibility_Camera_();
        if (typeof rebuildRigEligibility_Filter_ === "function") rebuildRigEligibility_Filter_();
        return;
      
      setRefreshBarYellow_(sh);
      }
    // --- Camera Kit Sheet ---
    case CK?.NAME:
      if (a1 === 'A3' && val === 'Add Camera') {
        if (typeof SkyPix_AddCamera_ === "function") SkyPix_AddCamera_();
        e.range.setValue('Add Camera...');
        return;
      }
       else {
        setRefreshBarYellow_(sh);
        return;
      }

    // --- Filter Kit Sheet ---
    case FK?.NAME:
    Logger.log('=== FILTER KIT CASE ENTERED - sheetName: "' + sheetName + '", FK?.NAME: "' + FK?.NAME + '" ===');
      // Color Picker Handler (row 14)

  if (editRow === 14 && editCol > 1 && val) {
    Logger.log('=== COLOR PICKER HANDLER TRIGGERED ===');
    paintColorCell_(e.range, val);                // 100% color on the PICKER CELL ONLY

    const block = (typeof getFilterBlockForColumn_ === "function")
      ? getFilterBlockForColumn_(sh, editCol)
      : null;

    if (block) {
      // Base color from the picker cell we just painted
      const baseColor = e.range.getBackground();
      const numBands  = block.width / 2;         // 1..4 bands → 2,4,6,8 columns
      const shadePct  = [20, 15, 10, 5];         // use first N entries

      // Keep headers/subheaders untouched.
      // Apply shading to rows 4–15 (skip row 14) and 18–22 for THIS filter block.
      // J/K → 20%, L/M → 15%, next pairs → 10%, 5% (up to 4 bands).
      // Rows 25+ are intentionally not touched.

      // Row 4 and Row 15 are the only full-width rows we touch (per your existing design).
      sh.getRange(4,  block.startCol, 1, block.width).setBackground(hpcShade(baseColor, 20));
      sh.getRange(15, block.startCol, 1, block.width).setBackground(hpcShade(baseColor, 20));

      for (let b = 0; b < numBands; b++) {
        const bandCol = block.startCol + (b * 2);
        const pct     = shadePct[b] || 5;
        const shade   = hpcShade(baseColor, pct);

        // Rows 5–13 (filter data rows), skip row 14 (the picker)
        sh.getRange(5,  bandCol, 9, 2).setBackground(shade);

        // Rows 18–22 (transmission curve)
        sh.getRange(18, bandCol, 5, 2).setBackground(shade);
      }
    }
    return;
  }

      if (editRow === 2 && val === 'Refresh Rig Planners') {
  Logger.log('=== REFRESH HANDLER ===');
        if (typeof handlePlannerUpdate_ === "function") handlePlannerUpdate_();
        if (typeof styleRefreshBarNeutral_ === "function") styleRefreshBarNeutral_(sh);
        return;
      } else if (a1 === 'A3' && val && val.startsWith('Add')) {
  Logger.log('=== ADD FILTER HANDLER ===');
        if (typeof SkyPix_AddFilter_ === "function") SkyPix_AddFilter_(val);
        e.range.setValue('Add Filter...');
        return;
      } else if (editRow === 3 && (!val || val.trim() === '')) {
  Logger.log('=== DELETE FILTER HANDLER ===');
        const ui = SpreadsheetApp.getUi();
        const response = ui.alert(`Are you sure you want to delete filter "${oldVal}"?`, ui.ButtonSet.YES_NO);
        if (response == ui.Button.YES) {
          const mergedRange = e.range.getMergedRanges()[0];
          sh.deleteColumns(mergedRange.getColumn(), mergedRange.getWidth());
          if (typeof rebuildFilterKitLayout_ === "function") rebuildFilterKitLayout_();
        } else {
  Logger.log('=== ENTERED ELSE BLOCK ===');
          e.range.setValue(oldVal);
        }
        return;
     } else {
  Logger.log('=== ENTERED ELSE BLOCK - editRow: ' + editRow + ', editCol: ' + editCol);
  if (label === FK?.BAND_ID_LABEL) {
        const block = typeof getFilterBlockForColumn_ === "function" ? getFilterBlockForColumn_(sh, editCol) : null;
        if (block) {
          if (typeof populateDefaultBandData_ === "function") populateDefaultBandData_(sh, editCol, val);
          if (typeof populateTransmissionCurve_ === "function") populateTransmissionCurve_(sh, editCol, val);
          
          // Paint ONLY this band pair orange (rows 6-13, this band's 2 columns)
          sh.getRange(FK.ROWS.BANDWIDTH, editCol, (FK.ROWS.SUBSTRATE - FK.ROWS.BANDWIDTH + 1), 2).setBackground(WARN_ORANGE);
          
          // Also paint this band's transmission curve orange (rows 18-22)
          sh.getRange(18, editCol, 5, 2).setBackground(WARN_ORANGE);
          
          // Uncheck acknowledge defaults for this filter
          sh.getRange(FK.ROWS.ACK, block.startCol).setValue(false);
        }
      }


else if (editRow === FK?.ROWS?.ACK && val === 'TRUE') {
  const block = typeof getFilterBlockForColumn_ === "function" ? getFilterBlockForColumn_(sh, editCol) : null;
  if (block) {
    // Get the filter's chosen color from row 14 BACKGROUND
    const colorRange = sh.getRange(14, block.startCol, 1, block.width);
    const baseColor = colorRange.getBackground(); // Read background color directly
    
    const numBands = block.width / 2;
    const shadePercentages = [20, 15, 10, 5];
    
    const shade20 = hpcShade(baseColor, 20);
    
    // Row 3: SKIP - keep HPC header color
    
    // Row 4: Filter Model at 20%
    sh.getRange(4, block.startCol, 1, block.width).setBackground(shade20);
    
    // Row 15: Acknowledge Defaults at 20%
    sh.getRange(15, block.startCol, 1, block.width).setBackground(shade20);
    
    // Rows 5-13 and 18-22: Paint with graduated shades
    for (let b = 0; b < numBands; b++) {
      const bandCol = block.startCol + (b * 2);
      const shadedColor = hpcShade(baseColor, shadePercentages[b] || 5);
      
      sh.getRange(5, bandCol, 9, 2).setBackground(shadedColor);
      sh.getRange(18, bandCol, 5, 2).setBackground(shadedColor);
    }
    
      setRefreshBarYellow_(sh);
    }
  }
        setRefreshBarYellow_(sh);
        return;
}

    // --- Object Database Sheet ---
    case 'Object Database':
      if (editCol === 1 && editRow > 4 && val && val.startsWith('Smart Search')) {
        SpreadsheetApp.getActive().toast(`Running "${val}" for object: ${oldVal || ''}`);
        e.range.setValue(oldVal);
        return;
      }
      break;
  }
}


function showResolveProgress_(){
  const html = HtmlService.createHtmlOutput(
    `<!DOCTYPE html><html><head><meta name="google-apps-script-cando" content="true">
     <style>body{font-family:Arial;text-align:center;padding:14px}#s{font-weight:bold}</style></head>
     <body><div>Resolving objects…</div><div id="s">Starting…</div>
     <script>
       function step(){
         google.script.run.withSuccessHandler(function(res){
           document.getElementById('s').textContent = res.message || '';
           if (res.done){ setTimeout(()=>google.script.host.close(), 900); }
           else { setTimeout(step, 250); }
         }).doResolveBatch_();
       }
       window.addEventListener('load', step);
     </script></body></html>`
  ).setWidth(300).setHeight(140);
  SpreadsheetApp.getUi().showModalDialog(html,'Processing Objects…');
}

function doResolveBatch_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Entry');
  if (!sh) return {message:'Sheet not found', done:true};

  const { batchSize, auto } = _getBatchPrefs_();
  const props = PropertiesService.getScriptProperties();
  const lastRow = sh.getLastRow();

  // find where to start
  let row = Number(props.getProperty('SPX_RESOLVE_NEXT_ROW') || 5);
  let processed = 0;

  for (; row <= lastRow && processed < batchSize; row++){
    const id = String(sh.getRange(row,1).getDisplayValue() || '').trim();
    if (!id) continue;
    const st = String(sh.getRange(row,7).getDisplayValue() || '');
    if (st === 'Success' || st === 'Duplicate') continue;
    fetchSimbadData(sh.getRange(row,1));
    processed++;
    Utilities.sleep(120);
  }

  if (row > lastRow){
    props.deleteProperty('SPX_RESOLVE_NEXT_ROW');
    return { message: `Resolved ${processed} object(s). Done.`, done: true };
  } else {
    props.setProperty('SPX_RESOLVE_NEXT_ROW', String(row));
    if (auto) return { message: `Resolved ${processed} object(s). Continuing…`, done: false };
    return { message: `Resolved ${processed} object(s).`, done: true };
  }
}

/* ======================= Bulk Object Entry Resolving ======================= */

function SkyPix_BulkResolveRange_(rng){
  const sh = rng.getSheet();
  if (sh.getName() !== 'Object Entry') return;

  const start = Math.max(5, rng.getRow());                 // only rows ≥ 5
  const end   = start + rng.getNumRows() - 1;

  let resolved = 0;
  for (let r = start; r <= end; r++){
    const id = sh.getRange(r, 1).getDisplayValue().trim(); // A-column value
    if (!id) continue;

    const out = fetchSimbadData(sh.getRange(r, 1));        // resolve this row
    if (out === 'Success' || out === 'Duplicate') resolved++;

    Utilities.sleep(120);                                   // be gentle to APIs
  }

  if (resolved > 0) {
    // Turn the bar yellow and show the two choices
    setRefreshBarYellow_(sh);
  }

  SpreadsheetApp.getActive().toast(`Resolved ${resolved} object(s).`);
}

function SkyPix_BulkResolveSelected_(){
  const sh = SpreadsheetApp.getActiveSheet();
  if (!sh || sh.getName() !== 'Object Entry'){
    SpreadsheetApp.getUi().alert('Select a range on the "Object Entry" sheet.');
    return;
  }
  const rng = sh.getActiveRange();
  if (!rng) return;

  const firstRow = Math.max(5, rng.getRow());
  const lastRow  = rng.getLastRow();
  SkyPix_BulkResolveRange_(sh.getRange(firstRow, 1, lastRow - firstRow + 1, 1));
}


/* ======================= CANON CONSTANTS & HELPERS ======================= */
const TITLE_FS = 16, HEADER_FS = 12, LABEL_FS = 10, REFRESH_FS = 12;
const ROW_H_ALL = 36, ROW_H_HORIZON = 21, ROW_H_CURVE = 21;
const REFRESH_CHOICES_RIG = ['Refresh Kits', 'Refresh Air Quality Index', 'Refresh Bortle Class', 'Refresh Database', 'Refresh Planner', 'Cancel'];
const REFRESH_CHOICES_CAMERA = ['Refresh planner', 'Retrieve specifications', 'Cancel'];
const REFRESH_CHOICES_FILTER = ['Refresh planner', 'Retrieve specifications', 'Cancel'];
const REFRESH_CHOICES_DEFAULT = ['Refresh', 'Refresh Kits', 'Refresh Database'];
const REFRESH_CHOICES_SETUP = ['Refresh Rig Kit', 'Cancel'];
const REFRESH_CHOICES_DB_ONLY = ['Refresh Database', 'Update Database', 'Cancel'];
const REFRESH_LABEL_OPTION = 'Refresh';  // non-action label shown in the bar
const REFRESH_LABEL          = 'Refresh';             // default label
const CANCEL_LABEL           = 'Cancel';              // secondary action
const REFRESH_DB_LABEL       = 'Refresh Database';    // Object Entry special case

// Default choices for most sheets
const REFRESH_CHOICES        = [REFRESH_LABEL, CANCEL_LABEL];

// Optional: small visual nudge so the caret doesn't crowd the text
const REFRESH_LEFT_PAD_PX    = 8;
function padRefreshLabel_(s, px = REFRESH_LEFT_PAD_PX) {
  // ~6 px per NBSP at 10pt Arial; tweak if you change font/size
  const n = Math.max(0, Math.round(px / 6));
  return '\u00A0'.repeat(n) + s;
}
/* ===== PRECISION SETTINGS ===== */
const LATLON_DECIMALS = 4;   // 4 dp for lat/lon; elevation is integer elsewhere
const DEFAULT_HPC = '#4472c4'; 
const WARN_YELLOW = '#ffff00', WARN_ORANGE = '#ffa500';
const REFRESH_NEUTRAL_BG = '#e8e8e8';
const DARK_GREY_FONT = '#434343';

const COLOR_PICKER = [['Blue', '#1E90FF'], ['Deep Blue', '#0047AB'], ['Steel Blue', '#4682B4'], ['Cyan', '#00BCD4'], ['Light Blue', '#87CEFA'], ['Cornflower', '#6495ED'], ['Green', '#2E8B57'], ['Teal', '#008080'], ['Purple', '#7E57C2'], ['Magenta', '#D81B60'], ['Red', '#E53935'], ['Red Berry', '#9B111E'], ['Maroon', '#800000'], ['Brown', '#795548'], ['Slate', '#708090'], ['Navy', '#001F3F'], ['Dk Green', '#006400']];
const RDEF_LABELS = ['Rig model', 'Aperture (mm)', 'Central obstruction (mm)', 'Effective aperture area (mm²)', 'Effective focal length (mm)', 'Latitude (°) [N + / S -]', 'Longitude (°) [E + / W -]', 'Elevation above sea level (m)', 'Timezone UTC ±', 'DST start (MM-DD-YY)', 'DST end (MM-DD-YY)'];
const DFS_LABELS = ['Darkness convention', 'Times reported based on', 'Visibility reported as', 'Offset of transit/rising (minutes)', 'Display objects observable for the next... (months)', 'Display objects between declinations... (degrees)', 'Rig highlight color'];
const IMC_LABELS = [
  'Maximum integration time per object (hours)',
  'Maximum subframe exposure (seconds)',
  'Minimum object elevation (degrees)',
  'Expected ambient temp (°C)',
  'Sky Brightness',                        // was “Bortle class”
  'Air quality index',                     // stays, moved up with Sky Brightness
  'Minimum contiguous imaging time (min)', // new; replaces K (λ)
  'Lunar avoidance angle (degrees)'
];

function getLandHdrRow_(sh) {
  // Find the "Landscape Horizon" header row.
  let row = findRowWithText_(sh, 'Landscape Horizon');
  if (row) return row;

  // If it doesn't exist yet, create a minimal section and return its header row.
  const afterZenith = findRowWithText_(sh, 'Zenith Obstruction');
  const insertAt = (afterZenith ? afterZenith + 2 : Math.max(1, sh.getLastRow()) + 2);

  // Insert 3 rows: header + labels
  sh.insertRows(insertAt, 3);

  // Header (merged across A:C so it plays nicely with your layout)
  sh.getRange(insertAt, 1, 1, 3)
    .merge()
    .setValue('Landscape Horizon')
    .setHorizontalAlignment('left')
    .setVerticalAlignment('middle');

  // Column labels (Az/Alt) directly below the header so your later formatting calls work
  sh.getRange(insertAt + 1, 2).setValue('Az');
  sh.getRange(insertAt + 1, 3).setValue('Alt');

  return insertAt;
}

function getRefreshChoicesForSheet_(sh) {
  const name = sh && sh.getName ? sh.getName() : '';
  if (name === 'Setup')                   return REFRESH_CHOICES_SETUP;
  if (name === 'Rig kit')                 return REFRESH_CHOICES_RIG;
  if (name === CK.NAME)                   return REFRESH_CHOICES_CAMERA;
  if (name === FK.NAME)                   return ['Refresh Planner', 'Cancel'];
  if (name === 'Object Entry')            return REFRESH_CHOICES_DB_ONLY;
  // Object Database / anything else
  return REFRESH_CHOICES;
}

function getHPC_Global_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return DEFAULT_HPC;

  // Find the row that has the label “Header Primary Color”
  const row = findRowWithText_(sh, 'Header Primary Color');
  if (!row) return DEFAULT_HPC;

  const cell = sh.getRange(row, 3); // column C holds the picker
  const bg = (cell.getBackground() || '').toLowerCase();
  if (bg && bg !== '#ffffff') return bg;  // use the swatch color if present

  // Fallback to the dropdown text → hex map you already have
  const name = (cell.getDisplayValue() || '').trim();
  const hex  = nameToHex_(name);
  return hex || DEFAULT_HPC;
}


function _withRefreshLabelOption_(choices){
  const arr = (choices && choices.length) ? choices.slice() : [];
  if (!arr.includes(REFRESH_LABEL_OPTION)) arr.unshift(REFRESH_LABEL_OPTION);
  return arr;
}

function recolorAllSheets_() {
  const ss = SpreadsheetApp.getActive();
  recolorSetupSheet_(ss.getSheetByName('Setup'));
  recolorObjectEntrySheet_(ss.getSheetByName('Object Entry'));   // ← add
  recolorRigKitBands_(ss.getSheetByName('Rig kit'));
  recolorCameraKitBands_(ss.getSheetByName(CK.NAME));
  recolorFilterKitBands_(ss.getSheetByName(FK.NAME));
  recolorObjectDatabase_(ss.getSheetByName('Object Database'));  // ← add (needs Patch B)
}

function getSkyPixConfig(){
  const p = PropertiesService.getScriptProperties().getProperties() || {};
  return {
    cseKey:        p.CSE_KEY || '',
    cseCx:         p.CSE_CX || '',
    airNowApiKey:  p.AIRNOW_KEY || '',
    astrobinKey:   p.ASTROBIN_KEY || '',
    equipmentKey:  p.EQUIPMENT_API_KEY || '',
    lpollutionKey: p.LPOLLUTION_KEY || ''
  };
}

/* ===== SETUP-LATLON-HELPERS — START (SAFE) ===== */
// Show the “Retrieve 4D Location” dropdown in C4 even after values are filled?
// Leave true to always keep the dropdown visible.
const C4_DROPDOWN_ALWAYS_VISIBLE = true;

function setupSheet_(sh) {
  // Fallback to the Setup sheet if nothing passed.
  return sh || SpreadsheetApp.getActive().getSheetByName('Setup') || null;
}

function setSetupLocationFinderDropdown_(sh) {
  sh = setupSheet_(sh); if (!sh) return;
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(['Retrieve 4D Location', 'Cancel'], true)
    .setAllowInvalid(true)
    .build();
  sh.getRange('C4').setDataValidation(dv);
}

function setSetupLatLonValidation_(sh) {
  sh = setupSheet_(sh); if (!sh) return;
  const dvLat = SpreadsheetApp.newDataValidation().requireNumberBetween(-90, 90).setAllowInvalid(true).build();
  const dvLon = SpreadsheetApp.newDataValidation().requireNumberBetween(-180, 180).setAllowInvalid(true).build();
  const dvEle = SpreadsheetApp.newDataValidation().requireNumberBetween(-1000, 10000).setAllowInvalid(true).build();
  sh.getRange('C4').setDataValidation(dvLat);   // latitude
  sh.getRange('C5').setDataValidation(dvLon);   // longitude
  sh.getRange('C7').setDataValidation(dvEle);   // elevation
}
/* ===== SETUP-LATLON-HELPERS — END (SAFE) ===== */

function SkyPix_Debug_TestObjectFetch_(){
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Object Entry');
  if (!sh) return ss.toast('Object Entry not found.');
  const row = sh.getActiveCell().getRow();
  if (row < 5) return ss.toast('Click a row ≥ 5 in column A with an Object ID first.');
  const aCell = sh.getRange(row, 1);
  if (!aCell.getDisplayValue()) return ss.toast('Enter an Object ID in column A first (e.g., M42).');
  const res = fetchSimbadData(aCell);
  ss.toast('Lookup result: ' + res);
}

/* ===== NUMBER-FORMAT HELPERS — START ===== */
function enforceSetupFormats_(sh) {
  sh = sh || SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return;
  sh.getRange('C4:C5').setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS)); // lat/lon
  sh.getRange('C6').setNumberFormat('0');                                   // elevation (moved to C6)
  sh.getRange('C8:C9').setNumberFormat('MM-dd-yy');                         // dates (unchanged)
}

function enforceRigFormats_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  try {
    getPairsFromHeaders_(sh).forEach(([cL]) => {
      sh.getRange(9,  cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(10, cL, 1, 2).setNumberFormat('0.0000');
      sh.getRange(11, cL, 1, 2).setNumberFormat('0');
      sh.getRange(12, cL, 1, 2).setNumberFormat('0');         // <--- ADD THIS LINE
      sh.getRange(13, cL, 1, 2).setNumberFormat('MM-dd-yy');
      sh.getRange(14, cL, 1, 2).setNumberFormat('MM-dd-yy');
    });
  } catch (e) {}
}
/* ===== NUMBER-FORMAT HELPERS — END ===== */
function SkyPix_CSE_(query, num) {
  const { cseKey, cseCx } = getSkyPixConfig();
  if (!cseKey || !cseCx) throw new Error('Missing CSE key/cx (Admin → Set API Keys…)');

  const url = 'https://customsearch.googleapis.com/customsearch/v1'
            + '?key=' + encodeURIComponent(cseKey)
            + '&cx='  + encodeURIComponent(cseCx)
            + '&num=' + encodeURIComponent(num || 3)
            + '&q='   + encodeURIComponent(query);

  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const data = JSON.parse(resp.getContentText() || '{}');
  if (resp.getResponseCode() !== 200) {
    throw new Error('CSE error ' + resp.getResponseCode() + ': ' + (data.error && data.error.message || ''));
  }
  return (data.items || []).map(i => ({ title: i.title, link: i.link, snippet: i.snippet }));
}
/* =========== On-Edit Trigger Helpers =============*/
/** Ensure the installable onEdit trigger exists (idempotent). */
function ensureOnEditTrigger_() {
  const ss = SpreadsheetApp.getActive();
  const triggers = ScriptApp.getProjectTriggers();

  // Remove broken/duplicate onEdit triggers for safety
  triggers.forEach(t => {
    if (t.getHandlerFunction() === 'onEditTrigger' && t.getEventType() === ScriptApp.EventType.ON_EDIT) {
      // keep exactly one; delete extras below
    }
  });

  const exists = triggers.some(t =>
    t.getHandlerFunction() === 'onEditTrigger' &&
    t.getEventType && t.getEventType() === ScriptApp.EventType.ON_EDIT
  );

  if (!exists) {
    ScriptApp.newTrigger('onEditTrigger')
      .forSpreadsheet(ss)      // bind to this sheet
      .onEdit()
      .create();
  }
}

/** Back-compat alias if any code still calls the old name. */
function installOnEditTrigger_() { ensureOnEditTrigger_(); }

/** Menu action: Enable onEdit Trigger */
function SkyPix_EnableOnEdit_() {
  try {
    ensureOnEditTrigger_();
    SpreadsheetApp.getActive().toast('onEdit trigger enabled.');
  } catch (e) {
    SpreadsheetApp.getActive().toast('Error enabling onEdit: ' + e.message);
  }
}

/** Optional: quick debugger to see triggers */
function SkyPix_Debug_ListTriggers_() {
  const lines = ScriptApp.getProjectTriggers().map(t =>
    `${t.getHandlerFunction()} — ${t.getEventType && t.getEventType()}`
  );
  Logger.log(lines.join('\n') || 'No triggers found');
}

/* ===== DUPLICATE onEditTrigger (OLD) — commented out by dridge3771 2025-11-07 =====
   This duplicate definition was removed to prevent ReferenceErrors.
   The canonical onEditTrigger is defined earlier in the file (around line 113).

// function onEditTrigger(e) {
//   const lock = LockService.getScriptLock();
//   if (!lock.tryLock(15000)) return;
//   try {
//     if (!e || !e.range) { Logger.log('onEditTrigger called without event; ignoring.'); return; }
//     logDebug_(`EDIT on ${e.range.getSheet().getName()}@${e.range.getA1Notation()} | Value: ${e.value}`);
//     SkyPix_DispatchOnChange_(e);
//   } catch (err) {
//     logDebug_('CRITICAL ERROR in onEditTrigger: ' + err.stack);
//   } finally {
//     lock.releaseLock();
//   }
// }

   ===== END DUPLICATE onEditTrigger ===== */

function RK_acknowledgeDefaults_(sh, col) {
  // Both columns in the pair: col and col+1
  [col, col + 1].forEach(c => {
    // List all rows that can have orange/yellow (expand as needed)
    const rows = [
      4,5,6,8,9,10,11,12,13,14,19,20,21,22,23,24,27,28,29,30,31,32,33,
      36,37,38, // Zenith
      41,42,43,44,45,46,47,48,49,50 // Horizon (expand as needed)
    ];
    rows.forEach(r => {
      const cell = sh.getRange(r, c);
      const bg = cell.getBackground();
      const val = cell.getValue();
      if ((bg === WARN_ORANGE || bg === WARN_YELLOW) && val !== "") {
        cell.setBackground(null);
      }
    });
  });
}

function RK_handleColorPicker_(sh, col, colorName) {
  if (!colorName) return;
  // Map of color names to hex codes
  const colorMap = {
    "Blue": "#1E90FF",
    "Deep Blue": "#00008B",
    "Steel Blue": "#4682B4",
    "Cyan": "#00FFFF",
    "Light Blue": "#ADD8E6",
    "Cornflower": "#6495ED",
    "Green": "#228B22",
    "Teal": "#008080",
    "Purple": "#800080",
    "Magenta": "#FF00FF",
    "Red": "#FF0000",
    "Red Berry": "#b22234",
    "Maroon": "#800000",
    "Brown": "#A52A2A",
    "Slate": "#708090",
    "Navy": "#000080",
    "Dk Green": "#006400"
  };
  const hex = colorMap[colorName] || "#FFFFFF";
  const cell = sh.getRange(16, col);
  cell.setBackground(hex);
  cell.setValue(""); // Remove the color name after painting
}

// Add this helper function near your other hpcShade functions
function applyFilterBandColors_(sh) {
  const filterBlocks = getFilterBlocks_(sh);
  
  filterBlocks.forEach(block => {
    const numBands = block.width / 2;
    
    // Get the filter's chosen color from row 14
    const colorCell = sh.getRange(14, block.startCol);
    const colorName = colorCell.getDisplayValue().trim();
    const baseColor = colorName ? (nameToHex_(colorName) || getHPC_Global_()) : getHPC_Global_();
    
    // Color picker cell stays at 100%
    sh.getRange(14, block.startCol, 1, block.width).setBackground(baseColor);
    
    // Apply graduated shades to each band
    const shadePercentages = [20, 15, 10, 5];
    for (let b = 0; b < numBands; b++) {
      const bandCol = block.startCol + (b * 2);
      const shadePercent = shadePercentages[b] || 5; // Default to 5% if >4 bands
      const shadedColor = hpcShade(baseColor, shadePercent);
      
      // Apply to all non-orange cells in this band
      // Rows 3-15: filter data
      for (let row = 3; row <= 15; row++) {
        if (row === 14) continue; // Skip color picker row
        const range = sh.getRange(row, bandCol, 1, 2);
        const bg = range.getBackground();
        if (bg.toLowerCase() !== WARN_ORANGE.toLowerCase()) {
          range.setBackground(shadedColor);
        }
      }
      
      // Rows 18-22: transmission curve
      for (let row = 18; row <= 22; row++) {
        const range = sh.getRange(row, bandCol, 1, 2);
        const bg = range.getBackground();
        if (bg.toLowerCase() !== WARN_ORANGE.toLowerCase()) {
          range.setBackground(shadedColor);
        }
      }
      
      // Rows 25+: rig eligibility checkboxes
      const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
      if (rigSheet) {
        const rigs = _rigkit_getRigSpecs_(rigSheet);
        for (let r = 0; r < rigs.length; r++) {
          sh.getRange(25 + r, bandCol, 1, 2).setBackground(shadedColor);
        }
      }
    }
  });
}

/* ============== SIMBAD Lookup Helpers ================ */
// Normalize common IDs so SIMBAD matches (e.g., "M42" → "M 42")
function _canonObjectId_(s){
  const t = String(s||'').trim().toUpperCase();
  const m = t.match(/^M\s*0*([1-9]\d*)$/);     if (m)  return 'M '   + m[1];
  const n = t.match(/^NGC\s*0*([1-9]\d*)$/);   if (n)  return 'NGC ' + n[1];
  const ic= t.match(/^IC\s*0*([1-9]\d*)$/);    if (ic) return 'IC '  + ic[1];
  return String(s||'').trim();
}

// SESAME text fallback
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (resp.getResponseCode() !== 200) return null;
  const txt  = resp.getContentText();
  const jpos = txt.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= txt.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2])
  };
}

// Generates SIMBAD-friendly identifier variants (Messier/NGC/IC/LBN/Sh2, combos)
function _genCandidates_(raw){
  const s = String(raw || '').trim();
  if (!s) return [];
  const out = new Set();

  const add = v => { if (v) out.add(String(v).trim()); };

  add(s);                               // as typed
  const T = s.replace(/\s+/g,' ').trim();

  // Generic "CAT####" -> "CAT ####"
  const m = T.match(/^([A-Za-z ]+)\s*([0-9][0-9A-Za-z\-]*)$/);
  if (m) add(`${m[1].trim()} ${m[2].trim()}`);

  // Messier (M42)
  let r = T.match(/^M\s*-?\s*(\d+)$/i);
  if (r){ add(`M ${r[1]}`); add(`M${r[1]}`); add(`Messier ${r[1]}`); }

  // NGC / IC / LBN / Caldwell
  [['NGC'],['IC'],['LBN'],['C','Caldwell']].forEach(([cat, alias])=>{
    r = T.match(new RegExp(`^${cat}\\s*-?\\s*(\\d+)$`,'i'));
    if (r){ add(`${cat} ${r[1]}`); add(`${cat}${r[1]}`); if (alias) add(`${alias} ${r[1]}`); }
  });

  // Sharpless (Sh 2-184, Sh2-184, Sh2 184, etc.)
  r = T.match(/^(SH2|SH\s*2)[-\s]*(\d+)$/i);
  if (r){
    const n = r[2];
    ['Sh 2-'+n,'Sh2-'+n,'Sh2 '+n,'Sh 2 '+n,'SH 2-'+n].forEach(add);
  }

  // Split combos like "NGC 281/SH2 184"
  if (/[\/,&]/.test(T)){
    T.split(/[\/,&]\s*/).forEach(p => _genCandidates_(p).forEach(add));
  }

  return Array.from(out);
}

/* =====================Object Entry Helpers =======================*/

// Split resolved label into catalog/common: "M 101 (Pinwheel Galaxy)" -> {catalog:"M 101", common:"Pinwheel Galaxy"}
function _splitResolvedName_(s){
  s = String(s || '').trim();
  if (!s) return { catalog:'', common:'' };
  const m = s.match(/^(.+?)\s*\((.+?)\)\s*$/);
  if (m) return { catalog: m[1].trim(), common: m[2].trim() };
  // Looks like a catalog-only label? leave common empty.
  if (/^(M|NGC|IC|LBN|UGC|PGC|ESO|Sh\s*2)[\s-]/i.test(s)) return { catalog: s, common: '' };
  // Otherwise treat as a plain common name
  return { catalog:'', common: s };
}

// Make a “catalog-like” ID texty & clean (no leading apostrophes Google Sheets sometimes adds)
function _cleanCatalogId_(s){
  s = String(s || '').trim();
  return s.replace(/^'/, '');   // drop a leading apostrophe if present
}

// Center a single Object Entry row (A..G)
function _centerEntryRow_(sh, row){
  sh.getRange(row, 1, 1, 7).setHorizontalAlignment('center').setVerticalAlignment('middle');
}

// Read batch preferences from Setup
function _getBatchPrefs_(){
  const setup = SpreadsheetApp.getActive().getSheetByName('Setup');
  const batchSize = Math.max(1, Number(setup?.getRange('C18').getValue() || 25));
  const auto = String(setup?.getRange('C19').getDisplayValue() || 'TRUE') === 'TRUE';
  return { batchSize, auto };
}

function _raHmsToDegrees_(s){
  const m = String(s||'').trim().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2}(?:\.\d*)?)$/);
  if (!m) return NaN;
  const h = +m[1], mi = +m[2], se = +m[3];
  return (h + mi/60 + se/3600) * 15;
}

function sortObjectDatabaseByRA_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return;

  const first = 5, last = sh.getLastRow();
  if (last < first) return;

  const width = 26; // A..Z per your layout
  const range = sh.getRange(first, 1, last - first + 1, width);
  const data  = range.getValues();

  data.sort((a, b) => {
    const raA = _raHmsToDegrees_(a[2]); // column C (0-based index 2)
    const raB = _raHmsToDegrees_(b[2]);
    if (isNaN(raA) && isNaN(raB)) return 0;
    if (isNaN(raA)) return 1;
    if (isNaN(raB)) return -1;
    return raA - raB;
  });

  range.setValues(data);
}

/* ======================= Object Entry Math ==============================*/
// ---------- Angle & time helpers ----------
const DEG2RAD = Math.PI / 180, RAD2DEG = 180 / Math.PI;

function jdFromDate_(d){ // UTC → JD
  const Y = d.getUTCFullYear(), M = d.getUTCMonth() + 1, D = d.getUTCDate();
  const h = d.getUTCHours(), m = d.getUTCMinutes(), s = d.getUTCSeconds();
  let A = Math.floor((14 - M)/12);
  let y = Y + 4800 - A, m0 = M + 12*A - 3;
  let JDN = D + Math.floor((153*m0 + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
  const fracDay = (h + (m + s/60)/60) / 24;
  return JDN + fracDay - 0.5; // astronomical JD starts at noon
}

function julianCenturiesSinceJ2000_(jd){ return (jd - 2451545.0)/36525; }

// Meeus precession J2000 → epoch-of-date (zeta, z, theta in arcsec)
function precessionAnglesJ2000_(T){
  const t = T; // centuries since J2000
  const zeta  = (2306.2181*t + 0.30188*t*t + 0.017998*t*t*t) * (1/3600) * DEG2RAD;
  const z     = (2306.2181*t + 1.09468*t*t + 0.018203*t*t*t) * (1/3600) * DEG2RAD;
  const theta = (2004.3109*t - 0.42665*t*t - 0.041833*t*t*t) * (1/3600) * DEG2RAD;
  return { zeta, z, theta };
}

// Precess J2000 (ra,dec in deg) → equinox-of-date (deg)
function precessJ2000ToDate_(raDeg, decDeg, when){
  const jd = jdFromDate_(when), T = julianCenturiesSinceJ2000_(jd);
  const { zeta, z, theta } = precessionAnglesJ2000_(T);

  let ra = raDeg * DEG2RAD, dec = decDeg * DEG2RAD;

  const A = Math.cos(dec) * Math.sin(ra + zeta);
  const B = Math.cos(theta) * Math.cos(dec) * Math.cos(ra + zeta) - Math.sin(theta) * Math.sin(dec);
  const C = Math.sin(theta) * Math.cos(dec) * Math.cos(ra + zeta) + Math.cos(theta) * Math.sin(dec);

  const ra2  = (Math.atan2(A, B) + z) * RAD2DEG;
  const dec2 = Math.asin(C) * RAD2DEG;
  return { raDeg: (ra2 + 360) % 360, decDeg: dec2 };
}

// Apply proper motion (mas/yr) from J2000 to 'when' (deg → deg)
function applyProperMotion_(raDeg, decDeg, pmraMasYr, pmdecMasYr, when){
  if (!pmraMasYr && !pmdecMasYr) return { raDeg, decDeg };
  const years = (jdFromDate_(when) - 2451545.0) / 365.25;
  const decRad = decDeg * DEG2RAD;
  const dRAdeg  = (pmraMasYr ? (pmraMasYr / (3.6e6 * Math.max(Math.cos(decRad), 1e-6))) : 0) * years; // μα* / cosδ
  const dDEdeg  = (pmdecMasYr ? (pmdecMasYr / 3.6e6) : 0) * years;
  return { raDeg: raDeg + dRAdeg, decDeg: decDeg + dDEdeg };
}

// Convenience: J2000 + pm → JNow (today), in deg
function toEpochOfDate_(raJ2000Deg, decJ2000Deg, pmraMasYr, pmdecMasYr, when){
  const withPM  = applyProperMotion_(raJ2000Deg, decJ2000Deg, pmraMasYr, pmdecMasYr, when);
  return precessJ2000ToDate_(withPM.raDeg, withPM.decDeg, when);
}

/* ======================= HTML DIALOGS & WEB FUNCTIONS ======================= */
/** ---------- API keys: server side ---------- */

const KEY_NAMES = [
  'CSE_KEY',              // Google Custom Search API key
  'CSE_CX',               // Custom Search Engine ID
  'AIRNOW_KEY',
  'EQUIPMENT_API_KEY',
  'ASTROBIN_KEY',
  'LPOLLUTION_KEY'
];

function showApiKeysDialog_() {
  const html = HtmlService.createHtmlOutputFromFile('ApiKeysDialog')
    .setWidth(520)
    .setHeight(600);
  SpreadsheetApp.getUi().showModalDialog(html, 'Set API Keys');
}


function setApiKeysManually() {
  const ui = SpreadsheetApp.getUi();
  
  // Get Google API Key
  const googleKey = ui.prompt('Enter Google Custom Search API Key:', 'Starts with AIzaSy...', ui.ButtonSet.OK_CANCEL);
  if (googleKey.getSelectedButton() !== ui.Button.OK) return;
  
  // Get Google CX
  const googleCx = ui.prompt('Enter Google Custom Search Engine ID:', 'Your search engine ID', ui.ButtonSet.OK_CANCEL);
  if (googleCx.getSelectedButton() !== ui.Button.OK) return;
  
  // Get AirNow Key
  const airNowKey = ui.prompt('Enter AirNow API Key:', 'Your AirNow key (optional)', ui.ButtonSet.OK_CANCEL);
  if (airNowKey.getSelectedButton() !== ui.Button.OK) return;
  
  // Save keys
  const keys = {
    'CSE_KEY': googleKey.getResponseText().trim(),
    'CSE_CX': googleCx.getResponseText().trim(),
    'AIRNOW_KEY': airNowKey.getResponseText().trim()
  };
  
  try {
    PropertiesService.getScriptProperties().setProperties(keys);
    ui.alert('API keys saved successfully!');
  } catch (e) {
    ui.alert('Error saving keys: ' + e.message);
  }
}

function showLocationFinder(context, targetCell) {
  // Get the 50% HPC shade from your Apps Script function
  var hpcColor = hpcShade(getHPC_Global_(), 50);

  const htmlTemplate = HtmlService.createTemplate(`
    <!DOCTYPE html>
    <html>
    <head>
      <base target="_top">
      <meta name="google-apps-script-cando" content="true">
      <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css">
      <style>
        body {padding:10px;}
        #results{margin-top:10px;font-weight:bold;}
        #error{margin-top:10px;color:red;}
        #findBtn {
          background: <?= hpcColor ?>;
          color: #fff;
          border: none;
        }
        #updateBtn {
          background: #ddd;
          color: #aaa;
          border: none;
        }
        #updateBtn.enabled {
          background: <?= hpcColor ?>;
          color: #fff;
        }
      </style>
    </head>
    <body>
      <input type="hidden" id="context" value="<?= context ?>">
      <input type="hidden" id="targetCell" value="<?= targetCell ?>">
      <div class="block">
        <label for="address">Enter Address or Location:</label>
        <input type="text" id="address" style="width:95%;">
      </div>
      <div class="block" style="margin-top:10px;">
        <button class="action" id="findBtn">Find</button>
        <button id="updateBtn" disabled>Update Sheet</button>
      </div>
      <div id="results"></div>
      <div id="error"></div>
      <script>
        let foundData = null;
        const findBtn = document.getElementById("findBtn");
        const updateBtn = document.getElementById("updateBtn");
        function updateDisplay(e) {
          findBtn.disabled = false;
          if (e.error) {
            document.getElementById("error").textContent = e.error;
            updateBtn.disabled = true;
            updateBtn.classList.remove("enabled");
            foundData = null;
            // Paint Find button (stay painted)
            findBtn.style.background = "<?= hpcColor ?>";
            findBtn.style.color = "#fff";
          } else {
            document.getElementById("error").textContent = "";
            document.getElementById("results").innerHTML = "Lat: " + e.lat.toFixed(6) + ", Lng: " + e.lng.toFixed(6);
            updateBtn.disabled = false;
            updateBtn.classList.add("enabled");
            foundData = e;
            // Unpaint Find, paint Update
            findBtn.style.background = "#ddd";
            findBtn.style.color = "#aaa";
            updateBtn.style.background = "<?= hpcColor ?>";
            updateBtn.style.color = "#fff";
          }
        }
        findBtn.addEventListener("click", () => {
          findBtn.disabled = true;
          google.script.run.withSuccessHandler(updateDisplay).geocodeAddress(document.getElementById("address").value);
        });
        updateBtn.addEventListener("click", () => {
          if(foundData) {
            google.script.run.withSuccessHandler(() => google.script.host.close())
              .updateCoordinates(
                foundData.lat, foundData.lng, foundData.elevation, foundData.timeZone,
                document.getElementById("context").value,
                document.getElementById("targetCell").value
              );
          }
        });
      </script>
    </body>
    </html>
  `);

  htmlTemplate.context = context || 'Setup';  
  htmlTemplate.targetCell = targetCell || '';
  htmlTemplate.hpcColor = hpcColor;
  const html = htmlTemplate.evaluate().setWidth(400).setHeight(250);
  SpreadsheetApp.getUi().showModalDialog(html, 'Find Location by Address');
}

function showProgressPie_() {
    const htmlContent = `<!DOCTYPE html><html><head><base target="_top"><meta name="google-apps-script-cando" content="true"><style>body{font-family:Arial,sans-serif;text-align:center;}p{font-size:14px;}#status{font-weight:bold;margin-top:10px;}</style></head><body><p>Processing entries...</p><p id="status">Starting update...</p>
    <script>function updateStatus(e){document.getElementById("status").textContent=e.message,(e.message.startsWith("Successfully")||e.message.startsWith("No new")||e.message.startsWith("Error"))&&setTimeout(()=>google.script.host.close(),2e3)}window.addEventListener("load",()=>google.script.run.withSuccessHandler(updateStatus).withFailureHandler(updateStatus).doObjectUpdate());</script></body></html>`;
    const html = HtmlService.createHtmlOutput(htmlContent).setWidth(300).setHeight(150);
    SpreadsheetApp.getUi().showModalDialog(html, 'Processing Objects...');
}

function getApiKeys_() {
  try {
    const p = PropertiesService.getScriptProperties().getProperties() || {};
    // return only what the dialog expects
    return {
      CSE_KEY:            p.CSE_KEY || '',
      CSE_CX:             p.CSE_CX || '',
      AIRNOW_KEY:         p.AIRNOW_KEY || '',
      EQUIPMENT_API_KEY:  p.EQUIPMENT_API_KEY || '',
      ASTROBIN_KEY:       p.ASTROBIN_KEY || '',
      LPOLLUTION_KEY:     p.LPOLLUTION_KEY || ''
    };
  } catch (e) {
    throw new Error('getApiKeys_ failed: ' + e.message);
  }
}

function setApiKeys_(keys) {
  try {
    const props = PropertiesService.getScriptProperties();
    KEY_NAMES.forEach(name => {
      const v = (keys && name in keys) ? String(keys[name] || '').trim() : '';
      props.setProperty(name, v);
      console.info(`setApiKeys_: ${name} = ${v ? '(set)' : '(empty)'}`);
    });
    return true;
  } catch (e) {
    throw new Error('setApiKeys_ failed: ' + e.message);
  }
}

function testApiConnection() {
  return 'Pong! Connection to the script server is working.';
}

/** Optional: quick editor test to verify saving path */
function testSaveKeys() {
  setApiKeys_({
    CSE_KEY: 'x', CSE_CX: 'y', AIRNOW_KEY: 'z',
    EQUIPMENT_API_KEY: '', ASTROBIN_KEY: '', LPOLLUTION_KEY: ''
  });
  console.info('testSaveKeys: completed');
}
/* ===== API-DLG — START: dialog-friendly key loaders/savers ===== */
function loadApiKeysForDialog() {
  // Return every stored property (safe—values are user-specific to this script)
  return PropertiesService.getScriptProperties().getProperties();
}

function saveApiKeysFromDialog(payload) {
  try {
    // Whitelist only the keys your UI actually supports:
    const allowed = ['CSE_KEY','CSE_CX','AIRNOW_KEY','ASTROBIN_KEY','LPOLLUTION_KEY'];
    const clean = {};
    allowed.forEach(k => {
      if (payload && Object.prototype.hasOwnProperty.call(payload, k)) {
        clean[k] = String(payload[k] || '').trim();
      }
    });
    PropertiesService.getScriptProperties().setProperties(clean, false); // merge, don’t wipe others
    return { ok: true };
  } catch (e) {
    return { ok: false, error: e.message || String(e) };
  }
}
/* ===== API-DLG — END ===== */

function geocodeAddress(address) {
  const { cseKey } = getSkyPixConfig();
  const apiKey = cseKey;
  if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
    return { error: 'Google API Key not set in Admin > Set API Keys.' };
  }
  const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
  try {
    const response = UrlFetchApp.fetch(url);
    const json = JSON.parse(response.getContentText());
    if (json.status === 'OK') {
      const loc = json.results[0].geometry.location;
      const elevUrl = `https://maps.googleapis.com/maps/api/elevation/json?locations=${loc.lat},${loc.lng}&key=${apiKey}`;
      const tzUrl = `https://maps.googleapis.com/maps/api/timezone/json?location=${loc.lat},${loc.lng}&timestamp=${Math.floor(Date.now() / 1000)}&key=${apiKey}`;
      
      const elevResponse = UrlFetchApp.fetch(elevUrl);
      const elevJson = JSON.parse(elevResponse.getContentText());
      const tzResponse = UrlFetchApp.fetch(tzUrl);
      const tzJson = JSON.parse(tzResponse.getContentText());

      const elevation = (elevJson.status === 'OK') ? elevJson.results[0].elevation : 0;
      const timeZone = (tzJson.status === 'OK') ? tzJson.rawOffset / 3600 : 0;

      return { lat: loc.lat, lng: loc.lng, elevation: elevation, timeZone: timeZone };
    } else {
      return { error: json.error_message || `Geocoding failed: ${json.status}` };
    }
  } catch (e) {
    return { error: e.message };
  }
}

function SkyPix_BuildObjectEntry() { buildObjectEntrySheet_(SpreadsheetApp.getActive()); }
function SkyPix_BuildSetup() { buildSetup_(SpreadsheetApp.getActive()); }
function SkyPix_BuildRigKit() { buildRigKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildCameraKit() { buildCameraKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildFilterKit() { buildFilterKit_(SpreadsheetApp.getActive()); }
function SkyPix_BuildObjectDatabase() { buildObjectDatabase_(SpreadsheetApp.getActive()); }

/* ======================= CORE HELPER FUNCTIONS ======================= */
function getHPC_Global_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Setup');
  if (!sh) return DEFAULT_HPC;

  // Find the row by label instead of hard-coding C12
  const row = findRowWithText_(sh, 'Header Primary Color');
  if (!row) return DEFAULT_HPC;

  const cell = sh.getRange(row, 3); // column C
  const val  = String(cell.getDisplayValue() || '').trim();

  // 1) If a named color was selected, map it using your existing COLOR_PICKER
  const hexFromName = nameToHex_(val);     // uses your existing map
  if (hexFromName) return hexFromName;

  // 2) If a literal hex was typed, accept it
  if (/^#?[0-9A-F]{6}$/i.test(val)) return val[0] === '#' ? val : ('#' + val);

  // 3) Else, fall back to the cell background if it’s been painted
  const bg = cell.getBackground();
  if (bg && bg.toLowerCase() !== '#ffffff') return bg;

  return DEFAULT_HPC;
}



function normalizeHexOrName_(s) {
  const t = String(s || '').trim();
  if (/^#[0-9a-f]{6}$/i.test(t)) return t;         // already a hex like #4472c4
  const byName = nameToHex_(t);
  return byName || DEFAULT_HPC;
}

function paintColorCell_(rng, picked) {
  const hex = nameToHex_(picked);
  if (!hex) return;
  rng.setBackground(hex).setValue('').setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
}

const styleSubheader_ = (range, fontColor) => {
    return center_(range)
        .setFontSize(HEADER_FS)
        .setFontWeight('bold')
        .setFontColor(fontColor);
};

const nameToHex_ = n => { 
  const hit = COLOR_PICKER.find(r => r[0].toLowerCase() === String(n).toLowerCase()); 
  return hit ? hit[1] : null; 
};

const hexIsDark_ = hex => { 
  const h = String(hex || '').replace('#', ''); 
  if (h.length !== 6) return false; 
  const r = parseInt(h.substr(0, 2), 16), g = parseInt(h.substr(2, 2), 16), b = parseInt(h.substr(4, 2), 16); 
  return (0.299 * r + 0.587 * g + 0.114 * b) < 140; 
};

function hpcShade(hex, pct) { const base = (hex && /^#?[0-9a-f]{6}$/i.test(hex)) ? (hex[0] === '#' ? hex : '#' + hex) : DEFAULT_HPC; const h = base.replace('#', ''); const r = parseInt(h.substr(0, 2), 16), g = parseInt(h.substr(2, 2), 16), b = parseInt(h.substr(4, 2), 16); const t = Math.max(0, Math.min(100, pct)) / 100; const nr = Math.round(255 + (r - 255) * t), ng = Math.round(255 + (g - 255) * t), nb = Math.round(255 + (b - 255) * t); return `#${[nr, ng, nb].map(v => v.toString(16).padStart(2, '0')).join('')}`; }
const center_ = rng => rng.setHorizontalAlignment('center').setVerticalAlignment('middle');
const leftLabel_ = rng => rng.setHorizontalAlignment('left').setVerticalAlignment('middle').setFontSize(LABEL_FS);
const rightLabel_ = rng => rng.setHorizontalAlignment('right').setVerticalAlignment('middle').setFontSize(LABEL_FS);

function stylePaddedCell_(range, text, bgColor, fontColor, isButton = false, leftPadPx = 0) {
  // Approximate pixels per "figure space" at typical 12pt—tweak if needed.
  // Using U+2007 (figure space) is more consistent than normal spaces.
  var pxPerSpace = 3.2;
  var nSpaces = Math.max(0, Math.round(leftPadPx / pxPerSpace));
  var pad = '\u2007'.repeat(nSpaces);

  var fullText = pad + (isButton ? text : text);
  var rtv = SpreadsheetApp.newRichTextValue().setText(fullText);

  // Hide the padding visually by coloring it the same as the background
  // so the text color logic stays clean.
  if (nSpaces > 0) {
    rtv.setTextStyle(0, pad.length,
      SpreadsheetApp.newTextStyle().setForegroundColor(bgColor).build());
  }
  rtv.setTextStyle(pad.length, fullText.length,
      SpreadsheetApp.newTextStyle().setForegroundColor(fontColor).build());

  // Center it (your existing helper)
  center_(range).setRichTextValue(rtv.build());
}


function getPairsFromHeaders_(sh) {
  const out = [];
  let c = 2;
  while (c + 1 <= sh.getMaxColumns()) {
    const hdr = String(sh.getRange(3, c).getDisplayValue() || '').trim();
    if (!hdr) break;
    out.push([c, c + 1]);
    c += 2;
  }
  return out;
}

function getActiveWidth_(sh) {
  const name = sh.getName();
  if (name === 'Setup' || name === 'Object Entry') return sh.getMaxColumns();
  if (name === 'Object Database') return 26;
  
  if (name === FK.NAME) {
    let lastCol = 1;
    let currentCol = 2;
    while (currentCol <= sh.getMaxColumns()) {
      const headerCell = sh.getRange(3, currentCol);
      if (headerCell.getDisplayValue()) {
        const mergedRange = headerCell.getMergedRanges()[0];
        lastCol = mergedRange.getLastColumn();
        currentCol = lastCol + 1;
      } else {
        break;
      }
    }
    return lastCol;
  }
  
  const pairs = getPairsFromHeaders_(sh);
  return pairs.length ? pairs[pairs.length - 1][1] : 3;
}

function mergeFullWidthRow_(sh, row) {
  const width = getActiveWidth_(sh) || sh.getMaxColumns();
  try { sh.getRange(row, 1, 1, sh.getMaxColumns()).breakApart(); } catch (_) { }
  sh.getRange(row, 1, 1, width).merge();
}

function writeRefreshLabel_(sh, bg, options) {
  const range = sh.getRange(2, 1);
  const bgColor = bg || REFRESH_NEUTRAL_BG;
  const choices = options || REFRESH_CHOICES_DEFAULT;

  mergeFullWidthRow_(sh, 2);

  // Use the global padding constant so the label has 10px left padding
  stylePaddedCell_(range, REFRESH_LABEL, bgColor, DARK_GREY_FONT, false, REFRESH_LEFT_PAD_PX);

  range.setFontSize(REFRESH_FS)
       .setFontWeight('bold')
       .setBackground(bgColor);

  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(choices, true)
    .setAllowInvalid(true)
    .build();
  range.setDataValidation(dv);
}



// Wrappers now ALWAYS use the two-choice list
const styleRefreshBarNeutral_ = (sh) =>
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, getRefreshChoicesForSheet_(sh));

const setRefreshBarYellow_ = (sh) =>
  writeRefreshLabel_(sh, WARN_YELLOW, getRefreshChoicesForSheet_(sh));


function isValueValid_(value, range) {
  const rule = range.getDataValidation();
  if (!rule) return true;

  const criteria = rule.getCriteriaType();
  const args = rule.getCriteriaValues();

  switch (criteria) {
    case SpreadsheetApp.DataValidationCriteria.NUMBER_BETWEEN:
      return value >= args[0] && value <= args[1];
    case SpreadsheetApp.DataValidationCriteria.NUMBER_GREATER_THAN:
      return value > args[0];
    case SpreadsheetApp.DataValidationCriteria.VALUE_IN_LIST:
      return args[0].indexOf(value) !== -1;
    default:
      return true;
  }
}

/* ---------- Refresh Kits orchestrator ---------- */
/* ===== MAIN ORCHESTRATOR ===== */

/**
 * Main refresh function - called from Rig Kit refresh bar
 * Propagates rig data to Camera Kit and Filter Kit
 */
function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) {
    ss.toast('Rig kit sheet not found.');
    return;
  }
  
  // Get rig specifications (name, color)
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  if (rigs.length === 0) {
    ss.toast('No rigs found in Rig kit.');
    return;
  }
  
  // Update Camera Kit
  const cameraSheet = ss.getSheetByName('Camera Kit');
  if (cameraSheet) {
    fixCameraKitAcknowledgeDefaults_(); // Fix structure first
    rebuildRigEligibility_Camera_Fixed_(cameraSheet, rigs);
    recolorCameraKitBands_(cameraSheet);
  }
  
  // Update Filter Kit
  const filterSheet = ss.getSheetByName('Filter Kit');
  if (filterSheet) {
    rebuildFilterKitLayout_(); // Restructure if needed
    rebuildRigEligibility_Filter_Fixed_(filterSheet, rigs);
    recolorFilterKitBands_(filterSheet);
  }
  
  ss.toast(`Rig eligibility refreshed for ${rigs.length} rig(s).`);
}

/* ===== HELPER: Extract Rig Specs from Rig Kit ===== */
/**
 * Extract rig specifications from Rig Kit
 * Returns: [{name, color}, ...]
 */
function _rigkit_getRigSpecs_(rigSh) {
  const blocks = _rigkit_getBlocks_(rigSh);
  const nameRow = 3;
  const colorRow = 16; // "Rig highlight color"
  
  const rigs = [];
  blocks.forEach(b => {
    const name = rigSh.getRange(nameRow, b.startCol).getDisplayValue().trim();
    if (!name || /^add rig/i.test(name)) return;
    
    let color = '';
    if (colorRow) {
      // Get the actual background color of the highlight color cell
      const colorCell = rigSh.getRange(colorRow, b.startCol);
      const bgColor = colorCell.getBackground();
      const textValue = colorCell.getDisplayValue().trim();
      
      // Use background color if painted, otherwise map text value
      if (bgColor && bgColor !== '#ffffff' && bgColor !== '#FFFFFF') {
        color = bgColor;
      } else if (textValue) {
        color = nameToHex_(textValue) || textValue;
      }
      
      // Fallback to HPC default if no color found
      if (!color) color = getHPC_Global_();
    }
    
    rigs.push({ name, color });
  });
  
  return rigs;
}

// Merge a section header across active rig columns (safe if already merged)
function rigkit_mergeSectionHeader_(sh, headerRow) {
  if (!sh || !headerRow) return;
  const width = Math.max(2, (typeof getActiveWidth_ === 'function' ? getActiveWidth_(sh) : sh.getMaxColumns()));
  try { sh.getRange(headerRow, 1, 1, width).merge(); } catch (e) {}
}

// Find a header row by exact text (returns null if missing)
function findRowWithText_(sh, text) {
  const f = sh.createTextFinder(text).matchEntireCell(true).findNext();
  return f ? f.getRow() : null;
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }

  // Find the exact label row. If it’s missing, we stop (no fallback).
  const colorRow = findRowWithText_(sh, 'Rig highlight color');
  if (!colorRow) { SpreadsheetApp.getUi().alert('“Rig highlight color” row not found.'); return; }

  // Build dropdown from your existing COLOR_PICKER list (names only).
  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(names, true)
    .setAllowInvalid(true)
    .build();

  // Apply to every active rig pair (B/C, D/E, …)
  const pairs = getPairsFromHeaders_(sh); // you already have this helper
  pairs.forEach(([cL/*, cR*/]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });

  ss.toast('Rig color picker restored.');
}

function _rigkit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  Logger.log('=== _rigkit_getBlocks_ DEBUG ===');
  Logger.log('Rig Kit active width: ' + width);
  Logger.log('Checking row 3 for rig headers...');
  
  // Log what's actually IN row 3, columns 2-10
  for (let c = 2; c <= Math.min(10, sh.getMaxColumns()); c++) {
    const val = sh.getRange(3, c).getDisplayValue().trim();
    Logger.log(`  Col ${c}: "${val}"`);
  }
  
  const blocks = [];
  let c = 2; // rigs start at column B
  
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const text = cell.getDisplayValue().trim();
    Logger.log(`Column ${c}: text="${text}"`);
    
    // Accept ANY text except "Add Rig..." or empty
    if (text && !/^add rig/i.test(text)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2; // Default to 2-column width
      Logger.log(`  ✓ Found rig: "${text}", startCol=${c}, width=${w}`);
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      Logger.log(`  ✗ Stopped at column ${c}: text empty or "Add Rig"`);
      break;
    }
  }
  
  Logger.log('Total blocks found: ' + blocks.length);
  Logger.log('=== END DEBUG ===');
  return blocks;
}

// Show the full Rig-kit refresh list (includes "Refresh Kits")
function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

// What "Refresh Kits" actually does
function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  // Rebuild camera & filter eligibility from current Rig kit
  rebuildRigEligibility_Camera_();
  rebuildRigEligibility_Filter_();

  // Re-run band coloring / headers so new rigs & colors reflect
  const ck = ss.getSheetByName(CK.NAME);
  if (ck) recolorCameraKitBands_(ck);
  const fk = ss.getSheetByName(FK.NAME);
  if (fk) recolorFilterKitBands_(fk);

  // Optional: ensure the rig color picker keeps working
  if (typeof rigkit_forceColorPicker_ === 'function') {
    rigkit_forceColorPicker_();
  }
  ss.toast('Camera/Filter kits refreshed from Rig kit.');
}

/* ---------- Camera Kit: rig eligibility area ---------- */
function _camerakit_refreshRigEligibility_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const border = hpcShade(hpc, 40);
  const width = getActiveWidth_(camSh);

  // Where the “Rig Eligibility” band starts
  const hdr = findRowWithText_(camSh, 'Rig Eligibility');
  if (!hdr) return;
  const startRow = hdr + 1;

  // Discover camera blocks so we can merge a checkbox lane per camera
  const blocks = _camerakit_getBlocks_(camSh);

  // Clear old rows under the header (keep formatting header itself)
  const clearRows = Math.max(1, rigs.length);
  camSh.getRange(startRow, 1, clearRows + 5, Math.max(3, width)).clearContent().removeCheckboxes();

  // Paint header band (keeps your look)
  camSh.getRange(hdr, 1, 1, width)
      .setBackground(hpcShade(hpc, 30))
      .setBorder(true, true, true, true, true, true, border, SpreadsheetApp.BorderStyle.SOLID);

  // Write each rig label in column A and create a merged checkbox lane per camera
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    const hex = nameToHex_(rig.color) || rig.color || '';
    const txtCell = camSh.getRange(row, 1).setValue(rig.name);
    if (hex) {
      const font = hexIsDark_(hex) ? '#FFFFFF' : '#000000';
      camSh.getRange(row, 1, 1, width).setBackground(hex).setFontColor(font);
    }
    // a checkbox “lane” per camera block
    blocks.forEach(b => {
      const r = camSh.getRange(row, b.startCol, 1, b.width).merge();
      r.insertCheckboxes().setHorizontalAlignment('center').setBorder(null, true, null, true, null, null, border, SpreadsheetApp.BorderStyle.SOLID);
    });
  });
}

// 1. Fix Row 32 validation to accept decimals (not just integers)
function rigkit_fixRow32Validation_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    // Allow Bortle (1.0-9.0) OR magnitude (14.0-25.0) as decimals
    const dv = SpreadsheetApp.newDataValidation()
      .requireNumberBetween(1.0, 25.0)
      .setAllowInvalid(true)
      .setHelpText('Enter Bortle class (1-9) or sky brightness (14-25 mag/arcsec²)')
      .build();
    
    sh.getRange(32, cL, 1, 2).setDataValidation(dv);
    
    // Check if current value is invalid and paint yellow if so
    const val = sh.getRange(32, cL, 1, 2).getValue();
    if (val && (val < 1 || (val > 9 && val < 14) || val > 25)) {
      sh.getRange(32, cL, 1, 2).setBackground(WARN_YELLOW);
    }
  });
}

// 2. Fix Acknowledge Defaults to unpaint ALL orange cells when checked
function rigkit_fixAcknowledgeDefaults_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    const ackCell = sh.getRange(15, cL, 1, 2);
    const isChecked = ackCell.getValue();
    
    if (isChecked === true) {
      // Define all data rows that should be unpainted
      const dataRowRanges = [
        [4, 6],   // Rig model through central obstruction
        [8, 14],  // Focal length through DST end
        [16, 16], // Color picker
        [19, 24], // Display content
        [27, 33], // Imaging constraints
        [36, 38], // Zenith obstruction
        [41, 50]  // Landscape horizon
      ];
      
      // Clear orange from all these ranges
      dataRowRanges.forEach(([startRow, endRow]) => {
        for (let r = startRow; r <= endRow; r++) {
          const range = sh.getRange(r, cL, 1, 2);
          const bg = range.getBackground();
          if (bg && bg.toLowerCase() === WARN_ORANGE.toLowerCase()) {
            range.setBackground(null);
          }
        }
      });
    }
  });
}

// 3. Fix color picker to paint the cell immediately when color is chosen
function rigkit_fixColorPicker_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL]) => {
    const colorCell = sh.getRange(16, cL, 1, 2);
    const colorName = String(colorCell.getDisplayValue() || '').trim();
    
    if (colorName) {
      const hex = nameToHex_(colorName);
      if (hex) {
        colorCell.setBackground(hex)
                 .setValue('') // Clear the text after painting
                 .setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
      }
    }
  });
}

// 4. Paint validation failures yellow
function rigkit_paintValidationFailures_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    // Check all validated cells
    const validatedRanges = [
      { row: 5, min: 10, max: 2000 },      // Aperture
      { row: 6, min: 0, max: 200 },        // Central obstruction
      { row: 8, min: 50, max: 10000 },     // Focal length
      { row: 9, min: -90, max: 90 },       // Latitude
      { row: 10, min: -180, max: 180 },    // Longitude
      { row: 11, min: -100, max: 5000 },   // Elevation
      { row: 12, min: -12, max: 12 },      // UTC
      { row: 22, min: 1, max: 12 },        // Observable months
      { row: 23, min: 10, max: 480 },      // Min observable time
      { row: 27, min: 0, max: 9999 },      // Max integration time
      { row: 28, min: 0, max: 999 },       // Max subframe exposure
      { row: 29, min: 0, max: 80 },        // Min elevation
      { row: 30, min: 0, max: 90 },        // Lunar avoidance
      { row: 31, min: -50, max: 50 },      // Ambient temp
      { row: 32, min: 1, max: 25 },        // Sky brightness (special case)
      { row: 33, min: 0, max: 200 }        // Air quality
    ];
    
    validatedRanges.forEach(({ row, min, max }) => {
      const cell = sh.getRange(row, cL, 1, 2);
      const val = cell.getValue();
      
      // Special handling for row 32 (gap between 9 and 14)
      if (row === 32 && val) {
        if (val < 1 || (val > 9 && val < 14) || val > 25) {
          cell.setBackground(WARN_YELLOW);
        }
      } else if (val && (val < min || val > max)) {
        cell.setBackground(WARN_YELLOW);
      }
    });
    
    // Check row 24 separately (not merged, two cells)
    const leftVal = sh.getRange(24, cL).getValue();
    const rightVal = sh.getRange(24, cR).getValue();
    if (leftVal && (leftVal < -90 || leftVal > 90)) {
      sh.getRange(24, cL).setBackground(WARN_YELLOW);
    }
    if (rightVal && (rightVal < -90 || rightVal > 90)) {
      sh.getRange(24, cR).setBackground(WARN_YELLOW);
    }
  });
}

// 5. Paint blank cells and helper text cells yellow
function rigkit_paintBlanksYellow_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    // Rows 5-12 (skip row 7 - calculated field)
    for (let row = 5; row <= 12; row++) {
      if (row === 7) continue; // Skip calculated effective aperture area
      
      const cell = sh.getRange(row, cL, 1, 2);
      const val = String(cell.getDisplayValue() || '').trim();
      
      if (!val) {
        cell.setBackground(WARN_YELLOW);
      }
    }
    
    // Rows 19-24 (row 24 is NOT merged, handle separately)
    for (let row = 19; row <= 23; row++) {
      const cell = sh.getRange(row, cL, 1, 2);
      const val = String(cell.getDisplayValue() || '').trim();
      
      if (!val) {
        cell.setBackground(WARN_YELLOW);
      }
    }
    
    // Row 24 special handling (two separate cells)
    const left24 = sh.getRange(24, cL);
    const right24 = sh.getRange(24, cR);
    const leftVal = String(left24.getDisplayValue() || '').trim();
    const rightVal = String(right24.getDisplayValue() || '').trim();
    
    if (!leftVal || leftVal === '> Dec') {
      left24.setBackground(WARN_YELLOW);
    }
    if (!rightVal || rightVal === '< Dec') {
      right24.setBackground(WARN_YELLOW);
    }
    
    // Rows 41-44 (Landscape Horizon - check for blanks or "Az"/"Alt" helpers)
    for (let row = 41; row <= 44; row++) {
      const azCell = sh.getRange(row, cL);
      const altCell = sh.getRange(row, cR);
      
      const azVal = String(azCell.getDisplayValue() || '').trim();
      const altVal = String(altCell.getDisplayValue() || '').trim();
      
      // Paint yellow if blank OR still showing helper text
      if (!azVal || azVal === 'Az') {
        azCell.setBackground(WARN_YELLOW);
      }
      if (!altVal || altVal === 'Alt') {
        altCell.setBackground(WARN_YELLOW);
      }
    }
  });
}

// 6. Ensure rows 22-23 are horizontally merged
function rigkit_mergeRows2223_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;
  
  const pairs = getPairsFromHeaders_(sh);
  
  pairs.forEach(([cL, cR]) => {
    try {
      sh.getRange(22, cL, 1, 2).merge();
      sh.getRange(23, cL, 1, 2).merge();
    } catch (e) {
      // Already merged or merge failed
    }
  });
}

function DEBUG_CheckRigPairs() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  const pairs = getPairsFromHeaders_(sh);
  
  Logger.log('Number of rig pairs found: ' + pairs.length);
  pairs.forEach(([cL, cR], i) => {
    Logger.log(`Rig ${i+1}: columns ${cL}-${cR}`);
    Logger.log(`  Header: ${sh.getRange(3, cL).getDisplayValue()}`);
  });
}

function SkyPix_FixRigKitValidation() {
  rigkit_fixRow32Validation_();
  rigkit_fixAcknowledgeDefaults_();
  rigkit_fixColorPicker_();
  rigkit_paintValidationFailures_();
  rigkit_paintBlanksYellow_();
  rigkit_mergeRows2223_();
  
  SpreadsheetApp.getActive().toast('All Rig Kit validation fixes applied.');
}

// Helper function to get camera blocks (similar to your existing camera block detection)
function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2; // cameras start at column B
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2; // Default camera width
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}

function rebuildRigEligibility_Camera_Fixed_(camSh, rigs) {
  if (!camSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(camSh);
  
  // Find the Rig Eligibility header
  let eligHeader = findRowWithText_(camSh, 'Rig Eligibility');
  if (!eligHeader) {
    // Create Rig Eligibility section if it doesn't exist
    const lastDataRow = Math.max(15, camSh.getLastRow());
    camSh.insertRowsAfter(lastDataRow, 1);
    eligHeader = lastDataRow + 1;
    mergeFullWidthRow_(camSh, eligHeader);
    camSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
          .setBackground(hpcShade(hpc, 40))
          .setFontSize(12)
          .setFontWeight('bold')
          .setFontColor(DARK_GREY_FONT)
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
  }

  const startRow = eligHeader + 1;
  
  // Clear existing rig eligibility rows (generous clear)
  const clearRows = Math.max(rigs.length * 3, 20);
  if (startRow + clearRows <= camSh.getMaxRows()) {
    camSh.getRange(startRow, 1, clearRows, width)
        .clearContent()
        .removeCheckboxes()
        .setBackground(null)
        .setFontWeight('normal')
        .setFontColor('#000000');
  }

  // Get camera blocks for proper merging
  const cameraBlocks = _camerakit_getBlocks_(camSh);

  // Build rig triplets with proper HPC shading
  rigs.forEach((rig, i) => {
    const tripletStart = startRow + (i * 3);
    const checkboxRow = tripletStart;
    const fovRow = tripletStart + 1;
    const scaleRow = tripletStart + 2;
    
    // Get rig color and apply HPC shading (lighter shade for readability)
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60); // Lighter shade for better readability
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    // Apply rig name and color to all three rows
    camSh.getRange(checkboxRow, 1).setValue(rig.name).setFontWeight('normal');
    camSh.getRange(fovRow, 1).setValue('Field of View (arcminutes)').setFontWeight('normal');
    camSh.getRange(scaleRow, 1).setValue('Image Scale (arcsec/pixel)').setFontWeight('normal');
    
    // Apply HPC-shaded background to entire triplet across all columns
    camSh.getRange(checkboxRow, 1, 3, width)
        .setBackground(shadedColor)
        .setFontColor(fontColor);

    // Set up camera-specific cells for each camera block
    cameraBlocks.forEach(block => {
      // Checkbox row - merged across camera block
      camSh.getRange(checkboxRow, block.startCol, 1, block.width)
          .merge()
          .insertCheckboxes()
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');

      // FOV and Scale rows - merged across camera block  
      camSh.getRange(fovRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
          
      camSh.getRange(scaleRow, block.startCol, 1, block.width)
          .merge()
          .setValue('0')
          .setHorizontalAlignment('center')
          .setVerticalAlignment('middle');
    });
  });
}

// Fixed Filter Kit rig eligibility rebuild with proper HPC color shading
function rebuildRigEligibility_Filter_Fixed_(filterSh, rigs) {
  if (!filterSh || !rigs || !rigs.length) return;

  const hpc = getHPC_Global_();
  const width = getActiveWidth_(filterSh);
  
  // Find the Rig Eligibility header
  let eligHeader = findRowWithText_(filterSh, 'Rig Eligibility');
  if (!eligHeader) {
    // If no Rig Eligibility section exists, we need to rebuild the entire layout
    // This should normally be handled by rebuildFilterKitLayout_(), but we'll ensure it exists
    const ackRow = findRowWithText_(filterSh, 'Acknowledge Defaults');
    if (ackRow) {
      filterSh.insertRowsAfter(ackRow, 2);
      eligHeader = ackRow + 2;
      mergeFullWidthRow_(filterSh, eligHeader);
      filterSh.getRange(eligHeader, 1).setValue('Rig Eligibility')
              .setBackground(hpcShade(hpc, 40))
              .setFontSize(12)
              .setFontWeight('bold')
              .setFontColor(DARK_GREY_FONT)
              .setHorizontalAlignment('center')
              .setVerticalAlignment('middle');
    }
  }

  if (!eligHeader) return; // Safety check

  const startRow = eligHeader + 1;
  
  // Clear existing rig rows
  const clearRows = Math.max(rigs.length + 5, 10);
  if (startRow + clearRows <= filterSh.getMaxRows()) {
    filterSh.getRange(startRow, 1, clearRows, width)
            .clearContent()
            .removeCheckboxes()
            .setBackground(null)
            .setFontWeight('normal')
            .setFontColor('#000000');
  }

  // Get filter blocks for proper merging
  const filterBlocks = getFilterBlocks_(filterSh);

  // Add each rig as a row with proper HPC shading
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    
    // Get rig color and apply HPC shading
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 60); // Lighter shade for better readability
    const fontColor = hexIsDark_(shadedColor) ? '#FFFFFF' : '#000000';

    // Set rig name and apply color across entire row
    leftLabel_(filterSh.getRange(row, 1)).setValue(rig.name);
    filterSh.getRange(row, 1, 1, width)
            .setBackground(shadedColor)
            .setFontColor(fontColor);

    // Add checkbox for each filter block
    filterBlocks.forEach(block => {
      filterSh.getRange(row, block.startCol, 1, block.width)
              .merge()
              .insertCheckboxes()
              .setHorizontalAlignment('center')
              .setVerticalAlignment('middle');
    });
  });
}

/* ======================= SHEET BUILDERS & MODULES ======================= */

// --- Setup Module ---
function buildSetup_(ss) {
  const sh = ss.getSheetByName('Setup') || ss.insertSheet('Setup', 1);
  sh.clear(); sh.setName('Setup');
  while (sh.getMaxColumns() > 3) sh.deleteColumn(4);
  sh.setColumnWidths(1, 3, 120).setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);

  // Merge A2:C2, set neutral grey, no text, no dropdown
  sh.getRange('A2:C2').merge();
  sh.getRange('A2').setValue('');
  sh.getRange('A2').clearDataValidations();
  sh.getRange('A2').clearNote();
  sh.getRange('A2').setBackground(REFRESH_NEUTRAL_BG);

  // Set C4 with line wrapping
  sh.getRange('C4').setWrap(true);

  // Perform all row insertions first to establish the final layout
  sh.insertRows(10, 1); // Spacer before Display Colors
  sh.insertRows(16, 1); // Spacer before Batch Processing

  // Merge all full-width rows
  mergeFullWidthRow_(sh, 1);
  mergeFullWidthRow_(sh, 10);
  mergeFullWidthRow_(sh, 16);

  // Set all section titles
  sh.getRange('A1').setValue('Setup');
  sh.getRange('A3').setValue('Home Site Location');
  sh.getRange('A11').setValue('Display Colors');
  sh.getRange('A17').setValue('Batch Processing');
  sh.getRange('A3').setNote('Docs placeholder: how to set home site lat/lon/UTC/elevation.');
  sh.getRange('A11').setNote('Docs placeholder: how header/observability/warning colors are used.');
  sh.getRange('A17').setNote('Docs placeholder: how batch size & auto-continue work.');

  // Home Site Location section (Bortle removed)
  const home = ['Latitude (°) [N + / S -]', 'Longitude (°) [E + / W -]', 'Elevation (m)', 'UTC Offset (hrs)', 'DST Start (MM-DD-YY)', 'DST End (MM-DD-YY)'];
  home.forEach((t, i) => leftLabel_(sh.getRange(4 + i, 1, 1, 2).merge()).setValue(t).setWrap(true));
  
  const dvNum = (a, b) => SpreadsheetApp.newDataValidation().requireNumberBetween(a, b).setAllowInvalid(true).build();
  
  // Set up the Location Finder dropdown in C4
  setSetupLocationFinderDropdown_(sh);

  // Clear initial values and paint yellow for user input
  sh.getRange('C4:C7').clearContent();
  sh.getRange('C4:C9').setBackground(WARN_YELLOW);

  sh.getRange('C8:C9').setNumberFormat('MM-dd-yy').setDataValidation(SpreadsheetApp.newDataValidation().requireDate().setAllowInvalid(true).build());
  
  // Display Colors section
  leftLabel_(sh.getRange('A12:B12').merge()).setValue('Header Primary Color');
  leftLabel_(sh.getRange('A13:B13').merge()).setValue('Observability Primary Color'); // A13/B13
  leftLabel_(sh.getRange('A14:B14').merge()).setValue('Warning Color');
  leftLabel_(sh.getRange('A15:B15').merge()).setValue('Attention Color');

  const picker = SpreadsheetApp.newDataValidation().requireValueInList(COLOR_PICKER.map(r=>r[0]),true).setAllowInvalid(true).build();
  sh.getRange('C12:C13').setDataValidation(picker);
  paintColorCell_(sh.getRange('C12'), 'Blue');
  paintColorCell_(sh.getRange('C13'), 'Green');
  sh.getRange('C14').setBackground(WARN_YELLOW).setValue('');
  sh.getRange('C15').setBackground(WARN_ORANGE).setValue('');

  // Batch Processing section (row numbers corrected)
  leftLabel_(sh.getRange('A18:B18').merge()).setValue('Objects per batch');
  sh.getRange('C18').setValue(25).setBackground(WARN_ORANGE);
  leftLabel_(sh.getRange('A19:B19').merge()).setValue('Auto-continue batches');
  sh.getRange('C19').setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['TRUE','FALSE'],true).build()).setValue('TRUE').setBackground(WARN_ORANGE);
  leftLabel_(sh.getRange('A20:B20').merge()).setValue('# of Astrobin images to review');
  sh.getRange('C20').setValue(8).setDataValidation(dvNum(1, 25)).setBackground(WARN_ORANGE);
  
  // Acknowledge Defaults section (row number corrected)
  leftLabel_(sh.getRange('A21:B21').merge()).setValue('Acknowledge Defaults');
  sh.getRange('C21').insertCheckboxes();

  // Center all data cells (ranges corrected)
  center_(sh.getRange('C4:C9'));
  center_(sh.getRange('C12:C15'));
  center_(sh.getRange('C18:C21'));

  recolorSetupSheet_(sh);

  // Added missing call to create the refresh bar
  // styleRefreshBarNeutral_(sh);
  enforceSetupFormats_(sh); // <— add this line
  // Add refresh bar with Rig Kit propagation option
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh Rig Kit', 'Cancel']);
  
  sh.setFrozenRows(2);
}

function recolorSetupSheet_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);

  const title = sh.getRange(1, 1, 1, width).merge();
  styleSubheader_(title, '#FFFFFF');
  title.setBackground(hpcShade(hpc, 80)).setFontSize(TITLE_FS);

  const subheaderRows = [3, 11, 17]; 
  subheaderRows.forEach(row => {
      const subheaderRange = sh.getRange(row, 1, 1, width).merge();
      subheaderRange.setBackground(hpcShade(hpc, 40));
      styleSubheader_(subheaderRange, DARK_GREY_FONT);
  });
}

// --- Object Entry Module ---
function buildObjectEntrySheet_(ss) {
    const sh = ss.getSheetByName('Object Entry') || ss.insertSheet('Object Entry', 0);
    sh.clear(); sh.setName('Object Entry');
    while(sh.getMaxColumns() > 7) sh.deleteColumn(8);

    sh.setColumnWidth(1, 80);
    sh.setColumnWidth(2, 150);
    sh.setColumnWidth(3, 70);  // RA
    sh.setColumnWidth(4, 70);  // Dec
    sh.setColumnWidth(5, 50);
    sh.setColumnWidth(6, 50);
    sh.setColumnWidth(7, 60);

    // Make RA/Dec 10pt, no wrap
    sh.getRange('C:C').setFontSize(10).setWrap(false);
    sh.getRange('D:D').setFontSize(10).setWrap(false);

    // Title + header notes (placeholder docs + status explainer)
    sh.getRange('A1').setNote(
      'SkyPix Object Entry — documentation placeholder.\n' +
      'Paste IDs into column A (row 5+) to resolve and stage objects before refresh.'
    );
    sh.getRange('G3:G4').setNote(
      'Status values:\n' +
      '• Searching… — resolving object\n' +
      '• Success — ready for database\n' +
      '• Duplicate (Entry) — same ID/name exists in Object Entry\n' +
      '• Duplicate — already in Object Database\n' +
      '• Not Found — no match in SIMBAD\n' +
      '• Error — lookup error; see cell note'
    );

    sh.setRowHeights(1, 2, 36).setRowHeights(3, 2, 25);

    center_(sh.getRange('A1:G1').merge()).setValue('Object Entry').setFontWeight('bold').setFontSize(TITLE_FS);
    styleRefreshBarNeutral_(sh);
    
    sh.getRange('A3:A4').mergeVertically();
    sh.getRange('B3:B4').mergeVertically();
    sh.getRange('C3:C4').mergeVertically();
    sh.getRange('D3:D4').mergeVertically();
    sh.getRange('G3:G4').mergeVertically();
    sh.getRange('E3:F3').merge();

    const formatHeaderLabel = (range, label) => center_(range).setVerticalAlignment('bottom').setFontWeight('bold').setFontSize(10).setValue(label).setFontColor('#434343');
    formatHeaderLabel(sh.getRange('A3'), 'Object ID');
    formatHeaderLabel(sh.getRange('B3'), 'Object Name');
    formatHeaderLabel(sh.getRange('C3'), 'RA');
    formatHeaderLabel(sh.getRange('D3'), 'Dec');
    formatHeaderLabel(sh.getRange('E3'), 'Size (arcmin)');
    formatHeaderLabel(sh.getRange('E4'), 'Width');
    formatHeaderLabel(sh.getRange('F4'), 'Height');
    formatHeaderLabel(sh.getRange('G3'), 'Status');
    
    sh.getRange('A3:G4').setBorder(true, true, true, true, true, true, hpcShade(getHPC_Global_(), 40), SpreadsheetApp.BorderStyle.SOLID);
    sh.getRange('A5:G').setHorizontalAlignment('center').setVerticalAlignment('middle').setWrap(true);
    sh.setRowHeights(5, sh.getMaxRows() - 4, ROW_H_ALL);
    sh.setFrozenRows(4);
    recolorObjectEntrySheet_(sh);
}

function recolorObjectEntrySheet_(sh) {
    if (!sh) return;
    const hpc = getHPC_Global_();
    sh.getRange('A1').setBackground(hpcShade(hpc, 80)).setFontColor('#FFFFFF');
    sh.getRange('A3:G4').setBackground(hpcShade(hpc, 20));
}

/* ===== SIMBAD RESOLVER — helpers ===== */

function _degToHMS(deg) {
  // deg RA (0..360) → "HH:MM:SS"
  const totalSec = (deg / 15) * 3600;
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = Math.round(totalSec % 60);
  return [h, m, s].map(n => String(n).padStart(2, '0')).join(':');
}
function _degToDMS(deg) {
  // deg Dec (-90..+90) → "±DD:MM:SS"
  const sign = deg < 0 ? '-' : '+';
  const a = Math.abs(deg);
  const d = Math.floor(a);
  const mFloat = (a - d) * 60;
  const m = Math.floor(mFloat);
  const s = Math.round((mFloat - m) * 60);
  return sign + [d, m, s].map(n => String(n).padStart(2, '0')).join(':');
}

// Normalize inputs so SIMBAD matches: "M68" → "M 68", "NGC2841" → "NGC 2841"
function _canonObjectId_(s){
  const t = String(s||'').trim().toUpperCase();
  const m = t.match(/^M\s*0*([1-9]\d*)$/);     if (m)  return 'M '   + m[1];
  const n = t.match(/^NGC\s*0*([1-9]\d*)$/);   if (n)  return 'NGC ' + n[1];
  const ic= t.match(/^IC\s*0*([1-9]\d*)$/);    if (ic) return 'IC '  + ic[1];
  return String(s||'').trim();
}

// Split a resolved name into catalog (e.g. "M 42") and common name (e.g. "Orion Nebula")
// If not split-able, returns catalog as main_id and common as empty string.
function _splitResolvedName_(main_id) {
  // Example main_id: "M 42 (Orion Nebula)"
  const m = String(main_id || '').match(/^(.+?)\s*\((.+?)\)$/);
  if (m) {
    return { catalog: m[1].trim(), common: m[2].trim() };
  }
  // If no parentheses, try to split by comma
  const parts = String(main_id || '').split(',');
  if (parts.length > 1) {
    return { catalog: parts[0].trim(), common: parts.slice(1).join(',').trim() };
  }
  return { catalog: String(main_id || '').trim(), common: '' };
}

// SESAME fallback (very forgiving)
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (resp.getResponseCode() !== 200) return null;
  const txt  = resp.getContentText();
  const jpos = txt.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= txt.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2]),
  };
}


/* ===== DB-DUPS-0 — START: DB duplicate helpers ===== */
function _normId_(s){ return String(s || '').trim().toLowerCase(); }

function getObjectDatabaseIndex_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return { ids:new Set(), names:new Set() };
  const first = 5, last = sh.getLastRow();
  const n = Math.max(0, last - first + 1);
  if (n <= 0) return { ids:new Set(), names:new Set() };

  const ids   = sh.getRange(first, 1, n, 1).getDisplayValues().flat().map(_normId_).filter(Boolean);
  const names = sh.getRange(first, 2, n, 1).getDisplayValues().flat().map(_normId_).filter(Boolean);
  return { ids:new Set(ids), names:new Set(names) };
}

function isDuplicateObject_(objectId, mainName){
  const { ids, names } = getObjectDatabaseIndex_();
  const idn = _normId_(objectId);
  const nn  = _normId_(mainName);
  if (idn && ids.has(idn))   return { dup:true, where:'Object ID',   match:objectId };
  if (nn  && names.has(nn))  return { dup:true, where:'Object Name', match:mainName };
  return { dup:false };
}
/* ===== DB-DUPS-0 — END ===== */

/* ===== DB-DUPS-1 — START: in-sheet duplicate detector ===== */
function isDuplicateInEntrySheet_(entrySheet, currentRow, objectId, mainName){
  const first = 5, last = entrySheet.getLastRow();
  if (last < first) return null;
  const ids   = entrySheet.getRange(first, 1, last-first+1, 1).getDisplayValues().flat();
  const names = entrySheet.getRange(first, 2, last-first+1, 1).getDisplayValues().flat();
  const idn = _normId_(objectId);
  const nn  = _normId_(mainName);

  for (let i = 0; i < ids.length; i++){
    const r = first + i;
    if (r === currentRow) continue;
    if (idn && idn === _normId_(ids[i]))   return `Duplicate in Object Entry by Object ID at row ${r}`;
    if (nn  && nn  === _normId_(names[i])) return `Duplicate in Object Entry by Object Name at row ${r}`;
  }
  return null;
}
/* ===== DB-DUPS-1 — END ===== */

/** --------- Tiny HTTP helper with logging --------- */
function _httpFetchText_(url){
  const resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  const code = resp.getResponseCode();
  const text = resp.getContentText();
  Logger.log(`[HTTP] ${code} ${url}\n${text.slice(0, 400)}...`);
  return { code, text };
}

/** --------- SIMBAD TAP via ident→basic join (best for “M 68” etc.) --------- */
function SkyPix_TAP_ByIdent_(ident){
  const adql =
    `SELECT TOP 1 b.main_id, b.ra, b.dec, b.pmra, b.pmdec
     FROM ident AS i JOIN basic AS b ON b.oid = i.oidref
     WHERE i.id='${String(ident).replace(/'/g,"''")}'`;
  const url = 'https://simbad.u-strasbg.fr/simbad/sim-tap/sync'
            + '?request=doQuery&lang=adql&format=tsv&query=' + encodeURIComponent(adql);
  const r = UrlFetchApp.fetch(url, { muteHttpExceptions:true });
  if (r.getResponseCode() !== 200) return null;
  const lines = (r.getContentText()||'').trim().split(/\r?\n/);
  if (lines.length < 2) return null;
  const c = lines[1].split('\t');
  const raDeg  = parseFloat(c[1]), decDeg = parseFloat(c[2]);
  if (isNaN(raDeg) || isNaN(decDeg)) return null;
  const pmra  = c[3] === '' ? 0 : parseFloat(c[3]);
  const pmdec = c[4] === '' ? 0 : parseFloat(c[4]);
  return { main_id: c[0] || ident, raDeg, decDeg, pmra, pmdec };
}

/** --------- SIMBAD simple endpoint (secondary try) --------- */
function SkyPix_SIMBAD_Simple_(ident){
  const url = 'https://simbad.u-strasbg.fr/simbad/sim-id?Ident='
            + encodeURIComponent(ident) + '&output.format=ASCII';
  const { code, text } = _httpFetchText_(url);
  if (code !== 200) return null;
  // crude pulls for “Coordinates (J2000)” lines
  const raM = text.match(/RA\s*:\s*([0-9.]+)\s*deg/i);
  const deM = text.match(/DEC\s*:\s*([+\-0-9.]+)\s*deg/i);
  const nmM = text.match(/Main identifier\s*:\s*(.+)/i);
  if (!raM || !deM) return null;
  return {
    main_id: (nmM && nmM[1].trim()) || ident,
    raDeg: parseFloat(raM[1]),
    decDeg: parseFloat(deM[1])
  };
}

/** --------- SESAME fallback (very forgiving) --------- */
function SkyPix_SESAME_(ident){
  const url  = 'https://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oI/A?' + encodeURIComponent(ident);
  const { code, text } = _httpFetchText_(url);
  if (code !== 200) return null;
  const jpos = text.match(/#JPOS\s*=\s*([0-9.+-]+)\s+([0-9.+-]+)/);
  if (!jpos) return null;
  const jname= text.match(/%J,NAME\s*=\s*(.*)/);
  return {
    main_id: (jname && jname[1] && jname[1].trim()) || ident,
    raDeg: parseFloat(jpos[1]),
    decDeg: parseFloat(jpos[2])
  };
}

/** --------- Guaranteed “don’t block me” fallback for a few Ms --------- */
const SKYPIX_MESSIER_FALLBACK = {
  'M 42':  { main_id:'M 42 (Orion Nebula)',         raDeg:83.8221,  decDeg:-5.3911,  maj:85,  min:60 },
  'M 3':   { main_id:'M 3 (NGC 5272)',              raDeg:205.5484, decDeg:28.3776,  maj:18,  min:18 },
  'M 68':  { main_id:'M 68 (NGC 4590)',             raDeg:189.8667, decDeg:-26.7447, maj:11,  min:11 },
  'M 101': { main_id:'M 101 (Pinwheel Galaxy)',     raDeg:210.8023, decDeg:54.3489,  maj:28.8,min:26.9 }
};

/** --------- Main: replace your current fetchSimbadData with this --------- */

function fetchSimbadData(cell){
  const sh  = cell.getSheet();
  const row = cell.getRow();
  const idRaw = _cleanCatalogId_(cell.getDisplayValue());

  const nameCell = sh.getRange(row, 2);
  const raCell   = sh.getRange(row, 3);
  const decCell  = sh.getRange(row, 4);
  const wCell    = sh.getRange(row, 5);
  const hCell    = sh.getRange(row, 6);
  const status   = sh.getRange(row, 7);

  // clear prior content/notes; show searching
  [nameCell, raCell, decCell, wCell, hCell, status].forEach(c => { c.clearNote(); });
  [nameCell, raCell, decCell, wCell, hCell].forEach(c => c.clearContent());
  status.setValue('Searching…');

  SpreadsheetApp.flush();

  try {
    // Try variants
    const tries = _genCandidates_(idRaw);
    let hit = null;
    let fallback = null;
    for (const ident of tries){
      fallback = SKYPIX_MESSIER_FALLBACK[ident];
      hit = SkyPix_TAP_ByIdent_(ident);
      if (!hit) hit = SkyPix_SIMBAD_Simple_(ident);
      if (!hit && fallback) hit = fallback;
      if (hit) break;
    }
    if (!hit){ status.setValue('Not Found'); _centerEntryRow_(sh, row); return 'Not Found'; }

    // Use fallback for name/size if available
    if (fallback) {
      // Use fallback main_id, size if missing
      if (!hit.main_id || hit.main_id === idRaw) hit.main_id = fallback.main_id;
      if (!('maj' in hit) && 'maj' in fallback) hit.maj = fallback.maj;
      if (!('min' in hit) && 'min' in fallback) hit.min = fallback.min;
    }

    // split catalog/common for display
    const nm = _splitResolvedName_(hit.main_id || idRaw);

    // Write values
    nameCell.setValue(nm.common || nm.catalog || idRaw);
    raCell.setValue(_degToHMS(hit.raDeg));
    decCell.setValue(_degToDMS(hit.decDeg));
    if ('maj' in hit && hit.maj != null) wCell.setValue(Number(hit.maj).toFixed(2));
    if ('min' in hit && hit.min != null) hCell.setValue(Number(hit.min).toFixed(2));

    // (duplicate checks… unchanged)
    const dupEntryMsg = isDuplicateInEntrySheet_(sh, row, idRaw, nm.common || nm.catalog || idRaw);
    if (dupEntryMsg){
      status.setValue('Duplicate (Entry)').setNote(dupEntryMsg);
      _centerEntryRow_(sh, row);
      return 'Duplicate';
    }
    const dupDb = isDuplicateObject_(idRaw, nm.common || nm.catalog || idRaw);
    if (dupDb.dup){
      status.setValue('Duplicate').setNote(`Already exists in Object Database by ${dupDb.where}: ${dupDb.match}`);
      _centerEntryRow_(sh, row);
      return 'Duplicate';
    }

    status.setValue('Success');
    _centerEntryRow_(sh, row);
    return 'Success';

  } catch (e) {
    status.setValue('Error').setNote(e.message || String(e));
    _centerEntryRow_(sh, row);
    return 'Error';
  }
}


/** Writes values + duplicate checks (uses your existing helpers). */
function _SkyPix_WriteObjectRow_(sh, row, idRaw, r, okLabel){
  const nameCell = sh.getRange(row, 2);
  const raCell   = sh.getRange(row, 3);
  const decCell  = sh.getRange(row, 4);
  const wCell    = sh.getRange(row, 5);
  const hCell    = sh.getRange(row, 6);
  const status   = sh.getRange(row, 7);

  // Object Name: show common name if available, otherwise catalog name, otherwise Object ID
  const nm = _splitResolvedName_(r.main_id || idRaw);
  nameCell.setValue(nm.common || nm.catalog || idRaw);

  raCell.setValue(_degToHMS(r.raDeg));
  decCell.setValue(_degToDMS(r.decDeg));
  if (r.maj != null) wCell.setValue(Number(r.maj).toFixed(2));
  if (r.min != null) hCell.setValue(Number(r.min).toFixed(2));

  // duplicate checks you already have
  const dupEntryMsg = isDuplicateInEntrySheet_(sh, row, idRaw, nm.common || nm.catalog || idRaw);
  if (dupEntryMsg){ status.setValue('Duplicate (Entry)'); status.setNote(dupEntryMsg); return 'Duplicate'; }
  const dupDb = isDuplicateObject_(idRaw, nm.common || nm.catalog || idRaw);
  if (dupDb.dup){ status.setValue('Duplicate'); status.setNote(`Already exists in Object Database by ${dupDb.where}: ${dupDb.match}`); return 'Duplicate'; }

  // r must include: r.raDeg, r.decDeg (deg) and optionally r.pmra, r.pmdec (mas/yr)
  const now = new Date();
  const jnow = toEpochOfDate_(r.raDeg, r.decDeg, r.pmra||0, r.pmdec||0, now);

  // Write epoch-of-date to the sheet
  raCell.setValue(_degToHMS(jnow.raDeg));
  decCell.setValue(_degToDMS(jnow.decDeg));

  // Optional: keep the raw J2000 in a note for traceability
  raCell.setNote(`J2000: ${_degToHMS(r.raDeg)}`);
  decCell.setNote(`J2000: ${_degToDMS(r.decDeg)}`);

  status.setValue(okLabel);
  return okLabel;
}

/** Menu tester you can run on the active row (keep this): */
function SkyPix_Debug_TestObjectFetch_(){
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Object Entry');
  if (!sh) return ss.toast('Object Entry not found.');
  const row = sh.getActiveCell().getRow();
  if (row < 5) return ss.toast('Click a row ≥ 5 in column A with an Object ID first.');
  const aCell = sh.getRange(row, 1);
  if (!aCell.getDisplayValue()) return ss.toast('Enter an Object ID in column A first (e.g., M42).');
  const res = fetchSimbadData(aCell);
  ss.toast('Lookup result: ' + res);
}

function processObjectEntries_() {
    const ss = SpreadsheetApp.getActive();
    const entrySheet = ss.getSheetByName('Object Entry');
    if (!entrySheet) return;
    const allData = entrySheet.getRange('A5:G' + entrySheet.getLastRow()).getValues();
    if (allData.filter(row => row[6] === 'Success' && row[0] !== '').length > 0) {
      showProgressPie_();
    } else {
      ss.toast('No new valid objects to update.');
    }
}

function doObjectUpdate() {
  const ss = SpreadsheetApp.getActive();
  const entrySheet = ss.getSheetByName('Object Entry');
  const dbSheet = ss.getSheetByName('Object Database');
  if (!entrySheet || !dbSheet) return { message: "Error: Could not find required sheets." };

  const data = entrySheet.getRange('A5:G' + entrySheet.getLastRow()).getValues();
  const validObjects = data.filter(row => row[6] === 'Success' && row[0] !== '');
  if (validObjects.length === 0) return { message: "No new valid objects to update." };

  // 1) Append to DB (A..D: ID, Name, RA, Dec)
  const startRow = dbSheet.getLastRow() + 1;
  dbSheet.getRange(startRow, 1, validObjects.length, 4)
        .setValues(validObjects.map(row => [row[0], row[1], row[2], row[3]]));

  // 2) Sort DB rows (5+) by RA (column C)
  sortObjectDatabaseByRA_();

  // 3) Clear Object Entry rows
  entrySheet.getRange('A5:G' + entrySheet.getLastRow()).clearContent();

  // 4) Reset the refresh bar on Object Entry to neutral (two options)
  styleRefreshBarNeutral_(entrySheet);

  return { message: `Successfully added ${validObjects.length} object(s).` };
}

function sortObjectDatabaseByRA_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
  if (!sh) return;

  const first = 5, last = sh.getLastRow();
  if (last < first) return;

  // Grab all visible columns (A..Z per your layout)
  const width = 26;
  const range = sh.getRange(first, 1, last - first + 1, width);
  const data  = range.getValues();

  data.sort((a, b) => {
    const raA = _raHmsToDegrees_(a[2]); // column C (0-based idx 2)
    const raB = _raHmsToDegrees_(b[2]);
    if (isNaN(raA) && isNaN(raB)) return 0;
    if (isNaN(raA)) return 1; // push blanks to bottom
    if (isNaN(raB)) return -1;
    return raA - raB;
  });

  range.setValues(data);
}



function updateCoordinates(lat, lng, elev, utc, context, targetCellA1) {
  const ss = SpreadsheetApp.getActive();
  
if (context === 'Setup') {
    const setupSheet = ss.getSheetByName('Setup');
    if (setupSheet) {
      // Store OLD values before update (for propagation system)
      const props = PropertiesService.getScriptProperties();
      const oldVals = setupSheet.getRange('C4:C7').getValues().flat();
      oldVals.forEach((val, i) => {
        props.setProperty(`SETUP_OLD_R${4 + i}`, String(val || ''));
      });
      
      // Update Setup with new location data
      const range = setupSheet.getRange('C4:C7');
      range.setValues([[lat.toFixed(6)], [lng.toFixed(6)], [elev], [utc]]);
      range.setBackground(null);
      setupSheet.getRange('C4:C5').setNumberFormat('0.' + '0'.repeat(LATLON_DECIMALS));
      setupSheet.getRange('C6').setNumberFormat('0');
      enforceSetupFormats_(setupSheet);
      
      // Paint refresh bar yellow to prompt user to sync rigs
      setRefreshBarYellow_(setupSheet);
      
      return "Setup coordinates updated.";
    }
  } else if (context === 'Rig kit') {
    const rigSheet = ss.getSheetByName('Rig kit');
    if (rigSheet && targetCellA1) {
      // Parse the target cell to get the column
      const targetCell = rigSheet.getRange(targetCellA1);
      const col = targetCell.getColumn();
      
      // Clear dropdown validation and set latitude value
      rigSheet.getRange(9, col, 1, 2).merge().clearDataValidations().setValue(lat.toFixed(6)).setBackground(null);
      // Set number validation for latitude
      const latValidation = SpreadsheetApp.newDataValidation().requireNumberBetween(-90, 90).setAllowInvalid(true).build();
      rigSheet.getRange(9, col, 1, 2).setDataValidation(latValidation);
      
      // Update other location fields
      rigSheet.getRange(10, col, 1, 2).merge().setValue(lng.toFixed(6)).setBackground(null);  // Longitude  
      rigSheet.getRange(11, col, 1, 2).merge().setValue(elev).setBackground(null);            // Elevation
      rigSheet.getRange(12, col, 1, 2).merge().setValue(utc).setBackground(null);             // UTC Offset
      
      rigSheet.getRange(11, col, 1, 2).merge()
        .setValue(Math.round(Number(elev || 0)))
        .setBackground(null)
        .setNumberFormat('0');                // <— make elevation integer

      enforceRigFormats_();                   // <— re-apply formats for the pair
      return "Rig coordinates updated.";

    }
  }
  return "Error: Target sheet not found.";
}

/**
 * Propagate Setup location data (C4-C9) to Rig Kit (rows 9-14)
 * Only updates rig cells that match the OLD Setup value (selective sync)
 */
function propagateSetupToRigs_() {
  const ss = SpreadsheetApp.getActive();
  const setupSh = ss.getSheetByName('Setup');
  const rigSh = ss.getSheetByName('Rig kit');
  
  if (!setupSh || !rigSh) {
    ss.toast('Setup or Rig kit sheet not found.');
    return;
  }
  
  // Get current (NEW) Setup values from C4-C9
  const newSetupVals = setupSh.getRange('C4:C9').getValues().flat();
  
  // Get OLD Setup values from Script Properties (captured during edit)
  const props = PropertiesService.getScriptProperties();
  const oldSetupVals = [];
  for (let row = 4; row <= 9; row++) {
    const key = `SETUP_OLD_R${row}`;
    const oldVal = props.getProperty(key);
    // Handle case where property doesn't exist yet (first edit after build)
    oldSetupVals.push(oldVal === null ? '' : oldVal);
  }
  
  // Get all rig column pairs
  const rigPairs = getPairsFromHeaders_(rigSh);
  if (rigPairs.length === 0) {
    ss.toast('No rigs found in Rig kit.');
    return;
  }
  
  let updatedRigCount = 0;
  let updatedCellCount = 0;
  
  // For each rig pair
  rigPairs.forEach(([cL, cR]) => {
    let rigHadUpdates = false;
    
    // Check each of the 6 location data rows (9-14)
    for (let i = 0; i < 6; i++) {
      const rigRow = 9 + i;           // Rig rows: 9, 10, 11, 12, 13, 14
      const setupIdx = i;             // Setup array index: 0, 1, 2, 3, 4, 5
      const oldSetupVal = oldSetupVals[setupIdx];
      const newSetupVal = newSetupVals[setupIdx];
      
      // Get the rig cell (merged across cL and cR)
      const rigCell = rigSh.getRange(rigRow, cL, 1, 2);
      const rigVal = rigCell.getValue();
      
      // Convert to strings for comparison (handles dates, numbers, blanks)
      const rigValStr = String(rigVal || '');
      const oldSetupValStr = String(oldSetupVal || '');
      
      // PROPAGATION LOGIC: Update if rig matches OLD Setup value
      // This includes blank === blank (initial setup case)
      if (rigValStr === oldSetupValStr) {
        rigCell.setValue(newSetupVal);
        rigCell.setBackground(null); // Unpaint (remove orange/yellow)
        rigHadUpdates = true;
        updatedCellCount++;
      }
    }
    
    if (rigHadUpdates) {
      updatedRigCount++;
    }
  });
  
  // Update stored OLD values to NEW values for next edit cycle
  for (let row = 4; row <= 9; row++) {
    const key = `SETUP_OLD_R${row}`;
    const idx = row - 4;
    props.setProperty(key, String(newSetupVals[idx] || ''));
  }
  
  // Apply proper number formatting to updated rig cells
  enforceRigFormats_();
  
  // Notify user
  if (updatedRigCount > 0) {
    ss.toast(`Updated ${updatedCellCount} cell(s) across ${updatedRigCount} rig(s).`);
  } else {
    ss.toast('No rigs matched the previous Setup values. No updates made.');
  }
}

/* ======================= COMPLETE RIG KIT MODULE (RESTRUCTURED) ======================= */

const RK_RDEF_LABELS = [
  'Rig model', 'Aperture (mm)', 'Central obstruction (mm)', 'Effective aperture area (mm²)', 
  'Effective focal length (mm)', 'Latitude (degrees [N+ / S-])', 'Longitude (degrees [E+ / W-])', 
  'Elevation above sea level (m)', 'Timezone UTC', 'DST start (MM-DD-YY)', 'DST end (MM-DD-YY)'
];

const RK_DFS_LABELS = [
  'Darkness convention',
  'Times reported based on...',
  'Object visibility reported as...',
  'Display objects observable for the next... (months)',
  'Display objects with a minimum observable time of... (minutes)',
  'Display objects between declinations... (degrees)'
];

const RK_IMC_LABELS = [
  'Maximum integration time per object (hours)', 'Maximum subframe exposure (minutes)', 'Minimum object elevation (degrees)',
  'Lunar avoidance angle (degrees)', 'Expected ambient temp (°C)', 'Sky Brightness (either Bortle Class or mag/arcsec^2)', 'Air quality index'
];

const RK_RDEF_START_ROW = 4;
const RK_COLOR_ROW = 16;
const RK_DFS_START_ROW = 18;
const RK_IMC_START_ROW = 27;
const RK_CRASH_CONE_START_ROW = 35;
const RK_HORIZON_HDR_ROW = 40;

function buildRigKit_(ss) {
  const sh = ss.getSheetByName('Rig kit') || ss.insertSheet('Rig kit', 2);
  sh.clear(); sh.setName('Rig kit');
  sh.clearConditionalFormatRules();

  sh.setColumnWidth(1, 200).setColumnWidths(2, sh.getMaxColumns() - 1, 45);
  sh.setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);
  sh.setRowHeight(RK_COLOR_ROW, 36);

  // Rig Definition Labels (rows 4-14)
  RK_RDEF_LABELS.forEach((t, i) => {
    const cell = leftLabel_(sh.getRange(RK_RDEF_START_ROW + i, 1)).setValue(t).setWrap(true);
    if (i === 0) cell.setWrap(true);
  });

  // Acknowledge Defaults row (Row 15)
  leftLabel_(sh.getRange(15, 1)).setValue('Acknowledge Defaults').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Rig Highlight Color row (Row 16)
  leftLabel_(sh.getRange(RK_COLOR_ROW, 1)).setValue('Rig Highlight Color').setFontSize(10).setFontWeight('normal').setFontColor(DARK_GREY_FONT);

  // Safe merge function
  const RK_safeFullWidthMerge = (row) => {
    try {
      const width = Math.max(3, RK_getActiveWidth_(sh) || 3);
      const range = sh.getRange(row, 1, 1, width);
      range.breakApart();
      range.merge();
    } catch (e) {
      console.log(`Merge warning for row ${row}: ${e.message}`);
    }
  };

  // Merge headers and section rows safely (including blank rows 17, 25, 39)
  [1, 2, 17, 18, 25, 26, 34, RK_CRASH_CONE_START_ROW, 39, RK_HORIZON_HDR_ROW].forEach(RK_safeFullWidthMerge);

  // Set section content
  sh.getRange(1, 1).setValue('Rig Kit');
  sh.getRange(17, 1).setValue(''); // blank
  sh.getRange(18, 1).setValue('Display Content');
  sh.getRange(25, 1).setValue(''); // blank
  sh.getRange(26, 1).setValue('Imaging Constraints');
  sh.getRange(34, 1).setValue('');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setValue('Zenith Obstruction');
  sh.getRange(39, 1).setValue(''); // blank
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setValue('Landscape Horizon');

  // DISPLAY CONTENT LABELS (rows 19-24)
  RK_DFS_LABELS.forEach((label, i) => {
    const row = RK_DFS_START_ROW + 1 + i;
    const cell = leftLabel_(sh.getRange(row, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Choose between Astronomical and Nautical twilight for darkness calculations'); break;
      case 1: cell.setNote('Base timing calculations on object transit or rising times'); break;
      case 2: cell.setNote('Report visibility windows as general visibility or optimal imaging conditions'); break;
      case 3: cell.setNote('Set forecast period for object visibility planning'); break;
      case 4: cell.setNote('Minimum continuous observation time required for an object to be included'); break;
      case 5: cell.setNote('Declination range limits for object visibility at your location'); break;
    }
  });

  // IMAGING CONSTRAINTS LABELS (rows 27-33)
  RK_IMC_LABELS.forEach((label, i) => {
    const cell = leftLabel_(sh.getRange(RK_IMC_START_ROW + i, 1)).setValue(label).setWrap(true);
    
    switch (i) {
      case 0: cell.setNote('Total time allocated for imaging this target across all sessions'); break;
      case 1: cell.setNote('Maximum exposure time per individual subframe to avoid trailing or saturation'); break;
      case 2: cell.setNote('Minimum altitude above horizon required for acceptable image quality'); break;
      case 3: cell.setNote('Angular distance from moon required to avoid interference'); break;
      case 4: cell.setNote('Expected ambient temperature for sensor cooling calculations'); break;
      case 5: cell.setNote('Local sky darkness rating affecting signal-to-noise ratio'); break;
      case 6: cell.setNote('Atmospheric transparency measurement affecting image quality'); break;
    }
  });

  // Zenith obstruction labels with note (A35)
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 1, 1)).setValue('Leg 1');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 2, 1)).setValue('Leg 2');
  rightLabel_(sh.getRange(RK_CRASH_CONE_START_ROW + 3, 1)).setValue('Leg 3');
  sh.getRange(RK_CRASH_CONE_START_ROW, 1).setNote('Define zenith obstruction cone using three azimuth/altitude coordinate pairs');
  sh.getRange(RK_HORIZON_HDR_ROW, 1).setNote('Define landscape horizon profile using azimuth/altitude coordinate pairs for terrain masking');

  const addRigCell = sh.getRange('A3');
  addRigCell.setDataValidation(
  SpreadsheetApp.newDataValidation()
    .requireValueInList(['Add Rig', 'Add Duplicate', 'Cancel'], true)
    .setAllowInvalid(true)
    .build()
  );
  addRigCell.setValue('Add Rig...');
  sh.getRange('B3').setValue('Rig 1');
  sh.getRange('B4:C34').setHorizontalAlignment('center').setVerticalAlignment('middle');

  RK_applyRigPairMerges_(sh, 2);

  // Merge rows 22 and 23 for all rig pairs at build
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL, cR]) => {
  try {
    sh.getRange(22, cL, 1, 2).merge();
    sh.getRange(23, cL, 1, 2).merge();
    } catch (e) {}
  });
  
  sh.setRowHeights(RK_CRASH_CONE_START_ROW + 1, 3, 36);
  sh.setRowHeight(RK_HORIZON_HDR_ROW, 36);
  sh.setRowHeights(RK_HORIZON_HDR_ROW + 1, 101, 36);

  RK_applyRigPairValidations_(sh, 2);
  RK_setupColorPickers_(sh);
  RK_setDefaultValues_(sh);
  RK_setupRigHelpers_(sh);
  RK_setupAcknowledgeDefaults_(sh);

  sh.setFrozenRows(3);
  recolorRigKitBands_(sh);
  enforceRigFormats_();
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}


/* ===== DUPLICATE Camera Kit (OLD) — commented out by dridge3771 2025-11-07 =====
   This duplicate Camera Kit definition causes ReferenceErrors when both definitions
   are active. The later Phase-2 Camera Kit (starting below) is the
   canonical, syntax-safe version and should remain active.
   
   Original block preserved below for reference and rollback purposes.
   ===== BEGIN COMMENTED OUT BLOCK ===== */

/*
/~* ==== BEGIN Camera Kit (Phase 2) Module — v15 (between Rig and Filter) ==== *~/

/~************************************************************
 * Camera Kit — Phase 2 Module (corrected v15)
 ************************************************************~/
var CK = (typeof CK === 'object') ? CK : {};
CK.NAME = CK.NAME || 'Camera Kit';
CK.ROWS = CK.ROWS || { TITLE:1, REFRESH:2, HEADERS:3, CAMERA_MODEL:4, SENSOR_MODEL:5, PIXEL_SIZE:6, SENSOR_SIZE:7, COOL_DELTA:8, UNITY_GAIN:9, READ_NOISE:10, DARK_CURRENT:11, FWC:12, COLOR:13, ACK:14, SPACER_1:15, QE_HDR:16, QE_L_EDGE:17, QE_L_INF:18, QE_PEAK:19, QE_U_INF:20, QE_U_EDGE:21, SPACER_2:22, RIG_HDR:23, RIG_FIRST:24 };

var COLORS = (typeof COLORS==='object')? COLORS : {};
if (!COLORS.Warn)    COLORS.Warn = '#FFA500';
if (!COLORS.Yellow)  COLORS.Yellow = '#FFFF99';

function ck_orange(){ return COLORS.Warn; }
function ck_yellow(){ return COLORS.Yellow; }
function ck_colorList_default_(){ return ['#FF6B6B','#51CF66','#339AF0','#FFD43B','#845EF7','#20C997','#FFFFFF','#000000']; }

function ck_aw_(sh){
  var lastCol = 3;
  var merges = sh.getRange(CK.ROWS.HEADERS, 2, 1, Math.max(2, sh.getMaxColumns()-1)).getMergedRanges();
  if (merges && merges.length){
    merges.forEach(function(r){
      if (r.getRow() === CK.ROWS.HEADERS){
        var right = r.getColumn() + r.getWidth() - 1;
        if (right > lastCol) lastCol = right;
      }
    });
  }
  if ((lastCol - 1) % 2 === 1) lastCol++;
  return Math.max(3, lastCol);
}
function ck_pairs_(sh){ var aw = ck_aw_(sh); var out=[]; for (var c=2;c<=aw;c+=2) out.push([c,c+1]); return out; }

function camerakit_enforcePairsAll_(sh){
  sh.setRowHeightsForced(1, Math.min(200, sh.getMaxRows()), 36);
  var aw = ck_aw_(sh);
  var mergeRows = [CK.ROWS.HEADERS, CK.ROWS.CAMERA_MODEL, CK.ROWS.SENSOR_MODEL, CK.ROWS.PIXEL_SIZE, CK.ROWS.COOL_DELTA, CK.ROWS.UNITY_GAIN, CK.ROWS.READ_NOISE, CK.ROWS.DARK_CURRENT, CK.ROWS.FWC, CK.ROWS.COLOR, CK.ROWS.ACK];
  for (var i=0;i<mergeRows.length;i++){
    var r = mergeRows[i];
    for (var c=2;c<=aw;c+=2){ try{ sh.getRange(r,c,1,2).merge(); }catch(e){} }
  }
  [CK.ROWS.SENSOR_SIZE, CK.ROWS.QE_L_EDGE, CK.ROWS.QE_L_INF, CK.ROWS.QE_PEAK, CK.ROWS.QE_U_INF, CK.ROWS.QE_U_EDGE].forEach(function(r){
    for (var c=2;c<=aw;c+=2){ try{ sh.getRange(r,c,1,2).breakApart(); }catch(e){} }
  });
}

function ck_applyColorDV_(sh){
  var pairs = ck_pairs_(sh);
  var list = (typeof ck_colorList_==='function') ? ck_colorList_() : ck_colorList_default_();
  var dv = SpreadsheetApp.newDataValidation().requireValueInList(list, true).setAllowInvalid(true).build();
  pairs.forEach(function(p){
    try{ sh.getRange(CK.ROWS.COLOR, p[0], 1, 2).merge(); }catch(e){}
    sh.getRange(CK.ROWS.COLOR, p[0]).setDataValidation(dv);
  });
}

function ck_paintMissingYellow_(sh){
  var pairs = ck_pairs_(sh); if (!pairs.length) return;
  var reqMerged = [CK.ROWS.CAMERA_MODEL,CK.ROWS.SENSOR_MODEL,CK.ROWS.PIXEL_SIZE,CK.ROWS.COOL_DELTA,CK.ROWS.UNITY_GAIN,CK.ROWS.READ_NOISE,CK.ROWS.DARK_CURRENT,CK.ROWS.FWC];
  var reqSplit  = [CK.ROWS.SENSOR_SIZE,CK.ROWS.QE_L_EDGE,CK.ROWS.QE_L_INF,CK.ROWS.QE_PEAK,CK.ROWS.QE_U_INF,CK.ROWS.QE_U_EDGE];

  reqMerged.forEach(function(r){
    pairs.forEach(function(p){
      var rng = sh.getRange(r, p[0], 1, 2);
      var v = (rng.getDisplayValue()||'').toString().trim();
      var bg = rng.getBackground();
      if (!v && (!bg || bg === '')) rng.setBackground(ck_yellow());
    });
  });
  reqSplit.forEach(function(r){
    pairs.forEach(function(p){
      var cL=p[0];
      try{ sh.getRange(r, cL, 1, 2).breakApart(); }catch(e){}
      [0,1].forEach(function(off){
        var cell = sh.getRange(r, cL+off);
        var v = (cell.getDisplayValue()||'').toString().trim();
        var bg = cell.getBackground();
        if (!v && (!bg||bg==='')) cell.setBackground(ck_yellow());
      });
    });
  });
}

function ck_mergeBandsToActiveWidth_(sh){
  var aw = ck_aw_(sh);
  function band(row, text){
    try{ sh.getRange(row,1,1,aw).merge(); }catch(e){}
    sh.getRange(row,1,1,aw).setValue(text||'').setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
  band(CK.ROWS.TITLE, 'Camera Kit');
  try{
    var dv = SpreadsheetApp.newDataValidation().requireValueInList(_withRefreshLabelOption_(getRefreshChoicesForSheet_(sh)), true).setAllowInvalid(true).build();
    sh.getRange(CK.ROWS.REFRESH,1,1,aw).merge().setDataValidation(dv).setValue(padRefreshLabel_ ? padRefreshLabel_('Refresh') : 'Refresh');
  }catch(e){}
  try{ sh.getRange(CK.ROWS.QE_HDR,1,1,aw).merge().setValue('Quantum Efficiency Curve'); }catch(e){}
  try{ sh.getRange(CK.ROWS.RIG_HDR,1,1,aw).merge().setValue('Rig Eligibility'); }catch(e){}
}

function ck_seedFirstPairAndDefaults_(sh){
  try{
    var dv = SpreadsheetApp.newDataValidation().requireValueInList(['Add Camera', 'Cancel'], true).setAllowInvalid(true).build();
    sh.getRange(CK.ROWS.HEADERS, 1).setDataValidation(dv).setValue('Add Camera...').setHorizontalAlignment('left');
  }catch(e){}
  try{ sh.getRange(CK.ROWS.HEADERS, 2, 1, 2).merge().setValue('Camera 1').setHorizontalAlignment('center'); }catch(e){}
  sh.getRange(CK.ROWS.CAMERA_MODEL, 2, 1, 2).merge().setValue('');
  sh.getRange(CK.ROWS.SENSOR_MODEL, 2, 1, 2).merge().setValue('Sony IMX571').setBackground(ck_orange());
  sh.getRange(CK.ROWS.PIXEL_SIZE,   2, 1, 2).merge().setValue(3.76).setBackground(ck_orange());
  try{ sh.getRange(CK.ROWS.SENSOR_SIZE, 2, 1, 2).breakApart(); }catch(e){}
  sh.getRange(CK.ROWS.SENSOR_SIZE, 2).setValue(6248).setBackground(ck_orange());
  sh.getRange(CK.ROWS.SENSOR_SIZE, 3).setValue(4176).setBackground(ck_orange());
  var q = [[CK.ROWS.QE_L_EDGE,400,0.2],[CK.ROWS.QE_L_INF,450,0.6],[CK.ROWS.QE_PEAK,530,0.8],[CK.ROWS.QE_U_INF,610,0.6],[CK.ROWS.QE_U_EDGE,680,0.2]];
  q.forEach(function(row){
    try{ sh.getRange(row[0],2,1,2).breakApart(); }catch(e){}
    sh.getRange(row[0],2).setValue(row[1]).setBackground(ck_orange());
    sh.getRange(row[0],3).setValue(row[2]).setBackground(ck_orange());
  });
}

function ck_rebuildRigTripletsAndCompute_(sh){
  var aw = ck_aw_(sh), pairs = ck_pairs_(sh);
  if (!pairs.length) return;

  // Get rigs from header merges on the "Rig kit" sheet
  var rigSh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSh) return;

  var rigPairs = [];
  var maxC = rigSh.getMaxColumns();
  for (var c=2; c<=maxC; c++){
    var nm = (rigSh.getRange(CK.ROWS.HEADERS, c).getDisplayValue() || '').trim();
    if (!nm) break;
    var m = rigSh.getRange(CK.ROWS.HEADERS, c).getMergedRanges();
    var w = (m && m.length) ? m[0].getWidth() : 2;
    rigPairs.push([c, c + w - 1]);
    c += (w - 1);
  }

  // Find focal-length row
  var focalRow = 0;
  var maxR = Math.min(200, rigSh.getMaxRows());
  for (var r=1; r<=maxR; r++){
    var label = String(rigSh.getRange(r,1).getDisplayValue() || '').toLowerCase();
    if (label.indexOf('effective focal length') >= 0 || (label.indexOf('focal') >= 0 && label.indexOf('mm') >= 0)){
      focalRow = r; break;
    }
  }

  // Paint triplets and compute FOV/Scale
  for (var i=0; i<rigPairs.length; i++){
    var base = CK.ROWS.RIG_FIRST + i*3;
    try { sh.getRange(base, 1, 3, aw).setBackground(COLORS.RigTint); } catch(_){}

    for (var p=0; p<pairs.length; p++){
      var cL = pairs[p][0];
      try { sh.getRange(base+1, cL, 1, 2).breakApart(); } catch(_){}
      try { sh.getRange(base+2, cL, 1, 2).merge(); } catch(_){}
      sh.getRange(base+1, cL, 1, 2).setHorizontalAlignment('center');
      sh.getRange(base+2, cL, 1, 2).setHorizontalAlignment('center');
    }

    if (!focalRow) continue;

    for (var p2=0; p2<pairs.length; p2++){
      var c0  = pairs[p2][0];
      var px  = parseFloat((sh.getRange(CK.ROWS.PIXEL_SIZE,  c0  ).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
      var wpx = parseFloat((sh.getRange(CK.ROWS.SENSOR_SIZE, c0  ).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
      var hpx = parseFloat((sh.getRange(CK.ROWS.SENSOR_SIZE, c0+1).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
      if (isNaN(px) || isNaN(wpx) || isNaN(hpx)) continue;

      var fmm = parseFloat((rigSh.getRange(focalRow, rigPairs[i][0]).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
      if (!fmm) continue;

      var scale = 206.265 * px / fmm;      // arcsec/px
      var fovW  = (scale * wpx) / 60.0;    // arcmin
      var fovH  = (scale * hpx) / 60.0;

      sh.getRange(base+1, c0  ).setNumberFormat('0.0').setValue(fovW);
      sh.getRange(base+1, c0+1).setNumberFormat('0.0').setValue(fovH);
      sh.getRange(base+2, c0, 1, 2).merge().setNumberFormat('0.000').setValue(scale);
    }
  }
}


function ck_onEditYellowAdjust_(e){
  try{
    var sh = e && e.range && e.range.getSheet ? e.range.getSheet() : null;
    if (!sh || sh.getName() !== CK.NAME) return;
    var r = e.range.getRow();
    var rowsMerged = [CK.ROWS.CAMERA_MODEL, CK.ROWS.SENSOR_MODEL, CK.ROWS.PIXEL_SIZE, CK.ROWS.COOL_DELTA, CK.ROWS.UNITY_GAIN, CK.ROWS.READ_NOISE, CK.ROWS.DARK_CURRENT, CK.ROWS.FWC];
    var rowsSplit  = [CK.ROWS.SENSOR_SIZE, CK.ROWS.QE_L_EDGE, CK.ROWS.QE_L_INF, CK.ROWS.QE_PEAK, CK.ROWS.QE_U_INF, CK.ROWS.QE_U_EDGE];
    var isTarget = (rowsMerged.indexOf(r)>=0 || rowsSplit.indexOf(r)>=0 || r===CK.ROWS.COLOR);
    if (!isTarget) return;
    var v = (e.value || '').toString().trim();
    if (!v){ if (!e.range.getBackground()) e.range.setBackground(ck_yellow()); }
    else{ if (e.range.getBackground() === ck_yellow()) e.range.setBackground(null); }
  }catch(err){}
}

function buildCameraKit_(ss){
  ss = ss || SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(CK.NAME);
  if (!sh) sh = ss.insertSheet(CK.NAME);
  if (sh.getMaxRows() < 60) sh.insertRowsAfter(sh.getMaxRows(), 60 - sh.getMaxRows());
  ck_mergeBandsToActiveWidth_(sh);
  camerakit_enforcePairsAll_(sh);
  ck_applyColorDV_(sh);
  var pairs = ck_pairs_(sh);
  var firstHasSensor = sh.getRange(CK.ROWS.SENSOR_MODEL, 2).getDisplayValue();
  if (!pairs.length || !firstHasSensor){ ck_seedFirstPairAndDefaults_(sh); }
  ck_rebuildRigTripletsAndCompute_(sh);
  ck_paintMissingYellow_(sh);
}

function SkyPix_AddCamera_(){
  var sh = SpreadsheetApp.getActive().getSheetByName(CK.NAME);
  if (!sh) return;
  var aw = ck_aw_(sh);
  sh.insertColumnsAfter(aw, 2);
  var insertCol = aw + 1;
  sh.getRange(CK.ROWS.HEADERS, insertCol, 1, 2).merge().setValue('New Camera').setHorizontalAlignment('center');
  camerakit_enforcePairsAll_(sh);
  ck_applyColorDV_(sh);
  ck_rebuildRigTripletsAndCompute_(sh);
  ck_paintMissingYellow_(sh);
}

/~* ==== END Camera Kit (Phase 2) Module ==== *~/
*/

/* ===== END DUPLICATE CAMERA KIT ===== */



/* ==== BEGIN Camera Kit (Phase 2) Module (in-place between Rig and Filter) ==== */
/************************************************************
 * Camera Kit — Phase 2 Drop-in Module (ck_final)
 * Safe to paste as a new file in Apps Script. Does not rename existing
 * global symbols outside the ck_* namespace.
 ************************************************************/

/* ===== Row map for Camera Kit (fixed layout, 36px rows) ===== */
var CK = (typeof CK === 'object') ? CK : {};
CK.ROWS = CK.ROWS || {
  TITLE: 1,
  REFRESH: 2,
  HEADERS: 3,
  CAMERA_MODEL: 4,
  SENSOR_MODEL: 5,
  PIXEL_SIZE: 6,
  SENSOR_SIZE: 7,     // two cells (W,H) per camera
  COOL_DELTA: 8,
  UNITY_GAIN: 9,
  READ_NOISE: 10,
  DARK_CURRENT: 11,
  FWC: 12,
  COLOR: 13,          // merged color picker cell
  ACK: 14,
  SPACER_1: 15,
  QE_HDR: 16,
  QE_L_EDGE: 17,      // two cells (λ, %)
  QE_L_INF: 18,       // two cells (λ, %)
  QE_PEAK: 19,        // two cells (λ, %)
  QE_U_INF: 20,       // two cells (λ, %)
  QE_U_EDGE: 21,      // two cells (λ, %)
  SPACER_2: 22,
  RIG_HDR: 23,
  RIG_FIRST: 24       // then triplets (A/B/C rows) per rig
};

/* ===== Colors (fallbacks) ===== */
var COLORS = (typeof COLORS==='object')? COLORS : {};
if (!COLORS.Warn) COLORS.Warn = '#FFD8A8';   // attention-orange
if (!COLORS.Yellow) COLORS.Yellow = '#FFF59D';
if (!COLORS.Band) COLORS.Band = '#7EA3C8';   // header band
if (!COLORS.RigTint) COLORS.RigTint = '#B3C7DF';

/* ===== Utilities ===== */









/* Enforce paired-column structure across active width */


/* Color picker DV on merged cells in Row 13 */


/* Paint required empties YELLOW (does not override ORANGE) */


/* Seed first pair if none; set sensor defaults (IMX571) per spec */


/* Build bands merged to active width (Title, Refresh, QE header, Rig header) */


/* --------- Rig Triplets + FOV/Scale --------- */


/* ===== Build entry ===== */
nment('middle');
      sh.getRange(41, newCol + 1).breakApart().setValue('Alt').setHorizontalAlignment('center').setVerticalAlignment('middle');
      // Center all horizon rows
      for (let r = 41; r <= 50; r++) {
        sh.getRange(r, newCol, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle');
      }
      // --- Setup mapping for rows 9-14 ---
      // Please check Setup sheet row mapping for your actual use; this is a generic example:
      // Setup: 4-lat, 5-lon, 6-Elevation, 7-Timezone, 8-DST start, 9-DST end
      if (setupSheet) {
        sh.getRange(9, newCol, 1, 2).setValue(setupSheet.getRange(4, 3).getValue());  // latitude
        sh.getRange(10, newCol, 1, 2).setValue(setupSheet.getRange(5, 3).getValue()); // longitude
        sh.getRange(11, newCol, 1, 2).setValue(setupSheet.getRange(6, 3).getValue()); // Elevation (now C6)
        sh.getRange(12, newCol, 1, 2).setValue(setupSheet.getRange(7, 3).getValue()); // UTC Offset (now C7)
        sh.getRange(13, newCol, 1, 2).setValue(setupSheet.getRange(8, 3).getValue()); // DST start
        sh.getRange(14, newCol, 1, 2).setValue(setupSheet.getRange(9, 3).getValue()); // DST end
        
        // Restore Location Finder dropdown in row 9 (gets overwritten by setValue above)
        const setupFinderDv = SpreadsheetApp.newDataValidation()
          .requireValueInList(['Retrieve 4D Location', 'Cancel'])
          .setAllowInvalid(true)
          .build();
        sh.getRange(9, newCol, 1, 2).setDataValidation(setupFinderDv);
      }
    

    // Always merge 15 & 16 for the new rig pair
    [15, 16].forEach(row => {
      try { sh.getRange(row, newCol, 1, 2).merge(); } catch(e){}
    });

    // Color picker for row 16, always blue by default
    const colorNames = ['Blue', 'Deep Blue', 'Steel Blue', 'Cyan', 'Light Blue', 'Cornflower', 'Green', 'Teal', 'Purple', 'Magenta', 'Red', 'Red Berry', 'Maroon', 'Brown', 'Slate', 'Navy', 'Dk Green'];
    const colorMap = {
      "Blue": "#1E90FF", "Deep Blue": "#00008B", "Steel Blue": "#4682B4", "Cyan": "#00FFFF",
      "Light Blue": "#ADD8E6", "Cornflower": "#6495ED", "Green": "#228B22", "Teal": "#008080",
      "Purple": "#800080", "Magenta": "#FF00FF", "Red": "#FF0000", "Red Berry": "#b22234",
      "Maroon": "#800000", "Brown": "#A52A2A", "Slate": "#708090", "Navy": "#000080", "Dk Green": "#006400"
    };
    const colorDV = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    sh.getRange(16, newCol, 1, 2)
      .setDataValidation(colorDV)
      .setBackground(colorMap["Blue"])
      .setValue('');

    // Acknowledge Defaults checkbox
    sh.getRange(15, newCol, 1, 2)
      .insertCheckboxes()
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle');

    // Defaults for rows 22 and 23
    sh.getRange(22, newCol, 1, 2).setValue(3).setHorizontalAlignment('center').setVerticalAlignment('middle');
    sh.getRange(23, newCol, 1, 2).setValue(60).setHorizontalAlignment('center').setVerticalAlignment('middle');

    // --- Row 7 formula and protection ---
    function getColLetter(colNum) {
      let temp = '';
      let letter = '';
      while (colNum > 0) {
        temp = (colNum - 1) % 26;
        letter = String.fromCharCode(temp + 65) + letter;
        colNum = (colNum - temp - 1) / 26;
      }
      return letter;
    }
    const apertureCol = getColLetter(newCol);
    const obstructionCol = getColLetter(newCol + 1);
    const formula = `=PI()*(${apertureCol}5/2)^2-PI()*(${obstructionCol}6/2)^2`;
    sh.getRange(7, newCol).setFormula(formula);
    sh.getRange(7, newCol + 1).setFormula(formula);
    sh.getRange(7, newCol, 1, 2)
      .setNote('Editing not allowed. Value is calculated.')
      .setDataValidation(
        SpreadsheetApp.newDataValidation()
          .requireTextEqualTo('') // Only allow blank (will always warn)
          .setAllowInvalid(true)
          .setHelpText('Editing not allowed. Value is calculated.')
          .build()
      );

    // Expand dynamic blank rows to include new rig
    if (typeof RK_expandBlankRows_ === "function") RK_expandBlankRows_(sh);

    // Re-merge section headers (for banding)
    [2, 17, 18, 25, 26, 34, 35, 39, 40].forEach(row => {
      try {
        const range = sh.getRange(row, 1, 1, newCol + 1);
        range.breakApart();
        range.merge();
      } catch (e) {}
    });

    SpreadsheetApp.getActive().toast(`Rig ${rigNumber} added successfully.`);
   catch (e) {
    SpreadsheetApp.getActive().toast('Error adding rig: ' + e.message);
  }

  // Always re-apply merges and validation fixes for all rigs
  if (typeof rigkit_mergeRows2223_ === "function") rigkit_mergeRows2223_();
  if (typeof rigkit_fixRow32Validation_ === "function") rigkit_fixRow32Validation_();
  if (typeof rigkit_fixColorPicker_ === "function") rigkit_fixColorPicker_();
  if (typeof rigkit_paintBlanksYellow_ === "function") rigkit_paintBlanksYellow_();

  // Merge rows 22-23 for the new rig as a patch
  try {
    const patchCol = sh.getLastColumn() - 1;
    sh.getRange(22, patchCol, 1, 2).merge();
    sh.getRange(23, patchCol, 1, 2).merge();
  } catch (e) {}

  // Ensure color picker is valid and blue for the new rig
  try {
    const patchCol = sh.getLastColumn() - 1;
    sh.getRange(16, patchCol, 1, 2)
      .setDataValidation(
        SpreadsheetApp.newDataValidation().requireValueInList(
          ['Blue', 'Red', 'Green', 'Purple', 'Slate', 'Red Berry', 'Navy', 'Dk Green'], true
        ).setAllowInvalid(true).build()
      )
      .setBackground("#1E90FF")
      .setValue('');
  } catch (e) {}

  // --- Always reset A3 after add
  sh.getRange('A3').setValue('');
  SpreadsheetApp.flush();
  sh.getRange('A3').setValue('Add Rig...');
}

function RK_expandBlankRows_(sh) {
  const width = RK_getActiveWidth_(sh);
  [17, 25, 34, 39].forEach(row => {
    try { 
      const range = sh.getRange(row, 1, 1, width); 
      range.breakApart(); 
      range.merge();
      range.setValue('').setBackground(null);
    } catch (e) {}
  });
}

function RK_updateAllRigHelpers_(sh) {
  try {
    const pairs = getPairsFromHeaders_(sh);
    pairs.forEach(([cL, cR]) => {
      sh.getRange(24, cL).setValue("> Dec").setHorizontalAlignment('center');
      sh.getRange(24, cR).setValue("< Dec").setHorizontalAlignment('center');
    });
    const colorNames = COLOR_PICKER ? COLOR_PICKER.map(r => r[0]) : ['Blue', 'Red', 'Green', 'Purple'];
    const dv = SpreadsheetApp.newDataValidation().requireValueInList(colorNames, true).setAllowInvalid(true).build();
    const hpc = getHPC_Global_();
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(16, cL, 1, 2); 
      cell.setDataValidation(dv); 
      cell.setBackground(hpc).setValue('');
    });
    pairs.forEach(([cL, cR]) => { 
      const cell = sh.getRange(15, cL, 1, 2); 
      try { 
        cell.breakApart(); 
        cell.merge(); 
        cell.insertCheckboxes(); 
        cell.setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } catch (e) {} 
    });
    const RK_CRASH_CONE_START_ROW = 35;
    pairs.forEach(([cL, cR]) => { 
      for (let i = 0; i < 3; i++) { 
        const row = RK_CRASH_CONE_START_ROW + 1 + i; 
        sh.getRange(row, cL).setValue('Az'); 
        sh.getRange(row, cR).setValue('Alt'); 
        sh.getRange(row, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
      } 
    });
    const RK_HORIZON_HDR_ROW = 40;
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL).setValue('Az'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cR).setValue('Alt'); 
      sh.getRange(RK_HORIZON_HDR_ROW + 1, cL, 1, 2).setHorizontalAlignment('center').setVerticalAlignment('middle'); 
    });
    const finderDv = SpreadsheetApp.newDataValidation().requireValueInList(['Retrieve 4D Location', 'Cancel']).setAllowInvalid(true).build();
    pairs.forEach(([cL, cR]) => { 
      sh.getRange(9, cL, 1, 2).setDataValidation(finderDv); 
    });
    RK_setDefaultValues_(sh);
  } catch (e) {}
}

function RK_handleAcknowledgeDefaults_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  if (row !== 15 || col < 2) return;
  const isChecked = e.range.getValue();
  if (isChecked !== true) return;
  
  try {
    // Find which rig pair (column pair) this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (!targetPair) return;
    
    const [cL, cR] = targetPair;
    
    // Data rows that should be cleared of orange if filled
    const dataRowRanges = [[4, 6], [8, 14], [16, 16], [27, 33], [36, 38]];
    
    // Critical rows that must have values - paint yellow if blank
    const criticalRanges = [
      [5, 6], [8, 12], [19, 24], [41, 44]
    ];
    
    // Clear orange from filled cells
    dataRowRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        const cell = sh.getRange(r, cL, 1, 2);
        const bg = cell.getBackground();
        const val = cell.getValue();
        
        if (bg && bg.toLowerCase() === WARN_ORANGE.toLowerCase()) {
          cell.setBackground(null);
        }
      }
    });
    
    // Paint critical blank cells yellow
    criticalRanges.forEach(([startRow, endRow]) => {
      for (let r = startRow; r <= endRow; r++) {
        // Check merged cell value
        const cell = sh.getRange(r, cL, 1, 2);
        const val = String(cell.getValue() || '').trim();
        
        // For row 41-44, check individual cells too for "Az"
        if (r >= 41 && r <= 44) {
          const leftVal = String(sh.getRange(r, cL).getValue() || '').trim();
          const rightVal = String(sh.getRange(r, cL + 1).getValue() || '').trim();
          if (!leftVal || leftVal === 'Az') {
            sh.getRange(r, cL).setBackground(WARN_YELLOW);
          }
          if (!rightVal || rightVal === 'Alt') {
            sh.getRange(r, cL + 1).setBackground(WARN_YELLOW);
          }
        } else {
          // For merged cells, check if empty
          if (!val) {
            cell.setBackground(WARN_YELLOW);
          }
        }
      }
    });
    
  } catch (error) {
    console.log('Acknowledge Defaults processing error:', error.message);
  }
}

function RK_handleCellEdit_(e) {
  const sh = e.range.getSheet();
  if (sh.getName() !== 'Rig kit') return;
  const row = e.range.getRow();
  const col = e.range.getColumn();
  
  // Handle color picker (row 16) - paint cell and CLEAR text immediately
  if (row === 16 && col >= 2) {
    const colorName = String(e.value || '').trim();
    if (colorName && colorName !== '') {
      const hex = nameToHex_(colorName);
      if (hex) {
        e.range.setBackground(hex);
        e.range.setValue('');
        e.range.setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
        return;
      }
    }
  }
  
  // Handle Acknowledge Defaults checkbox (row 15)
  if (row === 15 && col >= 2 && e.value === true) {
    // Find which rig pair this checkbox belongs to
    const pairs = getPairsFromHeaders_(sh);
    let targetPair = null;
    
    for (const [cL, cR] of pairs) {
      if (col >= cL && col <= cR) {
        targetPair = [cL, cR];
        break;
      }
    }
    
    if (targetPair) {
      const [cL, cR] = targetPair;
      
      // Clear orange/yellow from ALL data rows in this rig's column pair
      const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
      
      dataRowRanges.forEach(([startRow, endRow]) => {
        for (let r = startRow; r <= endRow; r++) {
          const cell = sh.getRange(r, cL, 1, 2);
          const bg = cell.getBackground();
          if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
            cell.setBackground(null);
          }
        }
      });
    }
    return;
  }
  
  // Smart unpaint: clear orange/yellow on user edit in data ranges
  const dataRowRanges = [[4, 6], [8, 14], [16, 16], [19, 24], [27, 33], [36, 38], [41, 50]];
  const isInDataRange = dataRowRanges.some(([start, end]) => row >= start && row <= end);
  if (isInDataRange && col >= 2) {
    const bg = e.range.getBackground();
    if (bg && (bg.toLowerCase() === WARN_ORANGE.toLowerCase() || bg.toLowerCase() === WARN_YELLOW.toLowerCase())) {
      e.range.setBackground(null);
    }
  }
  
  // Preserve 4D location finder dropdown after use
  if (row === 9 && col >= 2) {
    const finderDv = SpreadsheetApp.newDataValidation()
      .requireValueInList(['Retrieve 4D Location', 'Cancel'])
      .setAllowInvalid(true)
      .build();
    e.range.setDataValidation(finderDv);
  }
}

function getLandHdrRow_(sh) {
  let row = findRowWithText_(sh, 'Landscape Horizon');
  if (row) return row;
  const afterZenith = findRowWithText_(sh, 'Zenith Obstruction');
  const insertAt = (afterZenith ? afterZenith + 2 : Math.max(1, sh.getLastRow()) + 2);
  sh.insertRows(insertAt, 3);
  sh.getRange(insertAt, 1, 1, 3).merge().setValue('Landscape Horizon').setHorizontalAlignment('left').setVerticalAlignment('middle');
  sh.getRange(insertAt + 1, 2).setValue('Az');
  sh.getRange(insertAt + 1, 3).setValue('Alt');
  return insertAt;
}

function rigkit_mergeSectionHeader_(sh, headerRow) {
  if (!sh || !headerRow) return;
  const width = Math.max(2, (typeof getActiveWidth_ === 'function' ? getActiveWidth_(sh) : sh.getMaxColumns()));
  try { sh.getRange(headerRow, 1, 1, width).merge(); } catch (e) {}
}

function rigkit_forceColorPicker_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }
  const colorRow = 16;
  const names = COLOR_PICKER.map(r => r[0]);
  const dv = SpreadsheetApp.newDataValidation().requireValueInList(names, true).setAllowInvalid(true).build();
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    try { sh.getRange(colorRow, cL, 1, 2).breakApart(); } catch(e){}
    sh.getRange(colorRow, cL, 1, 2).merge().setDataValidation(dv);
  });
  ss.toast('Rig color picker restored.');
}



function rigkit_resetRefreshBar_(sh) {
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_RIG);
}

function refreshKits_() {
  const ss = SpreadsheetApp.getActive();
  const rigSheet = ss.getSheetByName('Rig kit');
  if (!rigSheet) return;
  const rigs = _rigkit_getRigSpecs_(rigSheet);
  const cameraSheet = ss.getSheetByName('Camera Kit');
  if (cameraSheet) {
    rebuildRigEligibility_Camera_Fixed_(cameraSheet, rigs);
    recolorCameraKitBands_(cameraSheet);
  }
  const filterSheet = ss.getSheetByName('Filter Kit');
  if (filterSheet) {
    rebuildRigEligibility_Filter_Fixed_(filterSheet, rigs);
    recolorFilterKitBands_(filterSheet);
  }
  SpreadsheetApp.getActive().toast('Camera Kit and Filter Kit refreshed from Rig kit.');
}

function _rigkit_getRigSpecs_(rigSh) {
  const blocks = _rigkit_getBlocks_(rigSh);
  const nameRow = 3;
  const colorRow = 16;
  const flRow = findRowWithText_(rigSh, 'Effective focal length');
  const rigs = [];
  blocks.forEach(b => {
    const name = rigSh.getRange(nameRow, b.startCol).getDisplayValue().trim();
    if (!name || /^add rig/i.test(name)) return;
    let color = '';
    if (colorRow) {
      const colorCell = rigSh.getRange(colorRow, b.startCol);
      const bgColor = colorCell.getBackground();
      const textValue = colorCell.getDisplayValue().trim();
      if (bgColor && bgColor !== '#ffffff' && bgColor !== '#FFFFFF') {
        color = bgColor;
      } else if (textValue) {
        color = nameToHex_(textValue) || textValue;
      }
      if (!color) color = getHPC_Global_();
    }
    const fl = flRow ? Number(rigSh.getRange(flRow, b.startCol).getDisplayValue()) : NaN;
    rigs.push({ name, color, focalLengthMM: fl });
  });
  return rigs;
}

function _camerakit_getBlocks_(sh) {
  const width = getActiveWidth_(sh);
  const blocks = [];
  let c = 2;
  while (c <= width) {
    const cell = sh.getRange(3, c);
    const label = cell.getDisplayValue().trim();
    if (label && label.match(/^Camera\s+\d+$/)) {
      const m = cell.getMergedRanges();
      const w = (m && m.length) ? m[0].getWidth() : 2;
      blocks.push({ startCol: c, width: w });
      c += w;
    } else {
      break;
    }
  }
  return blocks;
}


/************************************************************
 * Camera Kit — Phase 2 Module (v16, syntax-safe)
 * Layout:
 *  Row 1  : Title (full width)
 *  Row 2  : Refresh bar (full width)
 *  Row 3  : A3 “Add Camera...”; B:C = camera header (per pair)
 *  Rows 4–14 : Specs; Row 13 = Color Picker (merged per pair)
 *  Row 15 : Spacer (unpainted)
 *  Row 16 : QE header (full width)
 *  Rows 17–21 : QE curve (two cells per camera: λ, QE%)
 *  Row 22 : Spacer (unpainted)
 *  Row 23 : Rig Eligibility header (full width)
 *  Row 24+: Rig triplets per rig: (A) rig/checkboxes, (B) FOV W/H, (C) Image Scale
 ************************************************************/

/* Namespace + constants */
var CK = (typeof CK === 'object') ? CK : {};
CK.NAME = CK.NAME || 'Camera Kit';
CK.ROWS = CK.ROWS || {
  TITLE:1, REFRESH:2, HEADERS:3,
  CAMERA_MODEL:4, SENSOR_MODEL:5, PIXEL_SIZE:6,
  SENSOR_SIZE:7, COOL_DELTA:8, UNITY_GAIN:9,
  READ_NOISE:10, DARK_CURRENT:11, FWC:12,
  COLOR:13, ACK:14, SPACER_1:15,
  QE_HDR:16, QE_L_EDGE:17, QE_L_INF:18, QE_PEAK:19, QE_U_INF:20, QE_U_EDGE:21,
  SPACER_2:22, RIG_HDR:23, RIG_FIRST:24
};

var COLORS = (typeof COLORS==='object')? COLORS : {};
if (!COLORS.Warn)    COLORS.Warn = '#FFD8A8';   // attention orange
if (!COLORS.Yellow)  COLORS.Yellow = '#FFF59D';  // missing-data yellow
if (!COLORS.Band)    COLORS.Band = '#7EA3C8';   // band color
if (!COLORS.RigTint) COLORS.RigTint = '#E3ECF7'; // ~30% tint

function ck_orange(){ return COLORS.Warn; }
function ck_yellow(){ return COLORS.Yellow; }
function ck_colorList_default_(){ return ['#FF6B6B','#51CF66','#339AF0','#FFD43B','#845EF7','#20C997','#FFFFFF','#000000']; }

/* Active width from header merges; ensure even column count for pairs */
function ck_aw_(sh){
  var lastCol = 3;
  var merges = sh.getRange(CK.ROWS.HEADERS, 2, 1, Math.max(2, sh.getMaxColumns()-1)).getMergedRanges();
  if (merges && merges.length){
    for (var i=0;i<merges.length;i++){
      var r = merges[i];
      if (r.getRow() === CK.ROWS.HEADERS){
        var right = r.getColumn() + r.getWidth() - 1;
        if (right > lastCol) lastCol = right;
      }
    }
  }
  if ((lastCol - 1) % 2 === 1) lastCol++; // make it even
  return Math.max(3, lastCol);
}
function ck_pairs_(sh){ var aw = ck_aw_(sh), L=[]; for (var c=2;c<=aw;c+=2) L.push([c,c+1]); return L; }

/* Pair enforcement + row heights + split rows */
function camerakit_enforcePairsAll_(sh){
  var maxRows = Math.min(200, sh.getMaxRows());
  sh.setRowHeightsForced(1, maxRows, 36);

  var aw = ck_aw_(sh);
  var mergeRows = [CK.ROWS.HEADERS, CK.ROWS.CAMERA_MODEL, CK.ROWS.SENSOR_MODEL, CK.ROWS.PIXEL_SIZE,
                   CK.ROWS.COOL_DELTA, CK.ROWS.UNITY_GAIN, CK.ROWS.READ_NOISE, CK.ROWS.DARK_CURRENT,
                   CK.ROWS.FWC, CK.ROWS.COLOR, CK.ROWS.ACK];
  for (var i=0;i<mergeRows.length;i++){
    var r = mergeRows[i];
    for (var c=2;c<=aw;c+=2){ try{ sh.getRange(r,c,1,2).merge(); }catch(_){ } }
  }

  var splitRows = [CK.ROWS.SENSOR_SIZE, CK.ROWS.QE_L_EDGE, CK.ROWS.QE_L_INF, CK.ROWS.QE_PEAK, CK.ROWS.QE_U_INF, CK.ROWS.QE_U_EDGE];
  for (var j=0;j<splitRows.length;j++){
    var rr = splitRows[j];
    for (var c2=2;c2<=aw;c2+=2){ try{ sh.getRange(rr,c2,1,2).breakApart(); }catch(_){ } }
  }
}

/* Color Picker DV on row 13 merged cells */
function ck_applyColorDV_(sh){
  var pairs = ck_pairs_(sh);
  var list = (typeof ck_colorList_==='function') ? ck_colorList_() : ck_colorList_default_();
  var dv = SpreadsheetApp.newDataValidation().requireValueInList(list, true).setAllowInvalid(true).build();
  for (var i=0;i<pairs.length;i++){
    var cL = pairs[i][0];
    try{ sh.getRange(CK.ROWS.COLOR, cL, 1, 2).merge(); }catch(_){}
    sh.getRange(CK.ROWS.COLOR, cL).setDataValidation(dv);
  }
}

/* Yellow paint for required-but-empty, without overwriting orange defaults */
function ck_paintMissingYellow_(sh){
  var pairs = ck_pairs_(sh); if (!pairs.length) return;
  var reqMerged = [CK.ROWS.CAMERA_MODEL,CK.ROWS.SENSOR_MODEL,CK.ROWS.PIXEL_SIZE,CK.ROWS.COOL_DELTA,CK.ROWS.UNITY_GAIN,CK.ROWS.READ_NOISE,CK.ROWS.DARK_CURRENT,CK.ROWS.FWC];
  var reqSplit  = [CK.ROWS.SENSOR_SIZE,CK.ROWS.QE_L_EDGE,CK.ROWS.QE_L_INF,CK.ROWS.QE_PEAK,CK.ROWS.QE_U_INF,CK.ROWS.QE_U_EDGE];

  for (var i=0;i<reqMerged.length;i++){
    var r = reqMerged[i];
    for (var p=0;p<pairs.length;p++){
      var cL = pairs[p][0];
      var rng = sh.getRange(r, cL, 1, 2);
      var v = (rng.getDisplayValue()||'').toString().trim();
      var bg = rng.getBackground();
      if (!v && (!bg || bg==='')) rng.setBackground(ck_yellow());
    }
  }
  for (var j=0;j<reqSplit.length;j++){
    var rr = reqSplit[j];
    for (var p2=0;p2<pairs.length;p2++){
      var c0 = pairs[p2][0];
      try{ sh.getRange(rr, c0, 1, 2).breakApart(); }catch(_){}
      for (var k=0;k<2;k++){
        var cell = sh.getRange(rr, c0+k);
        var v2 = (cell.getDisplayValue()||'').toString().trim();
        var bg2 = cell.getBackground();
        if (!v2 && (!bg2 || bg2==='')) cell.setBackground(ck_yellow());
      }
    }
  }
}

/* Bands + labels (no external helpers, so always safe) */
function ck_mergeBandsToActiveWidth_(sh){
  var aw = ck_aw_(sh);
  function band(row, text, alignLeft){
    try{ sh.getRange(row,1,1,aw).merge(); }catch(_){}
    var rng = sh.getRange(row,1,1,aw);
    rng.setValue(text || '').setBackground(COLORS.Band).setFontColor('#ffffff').setVerticalAlignment('middle');
    rng.setHorizontalAlignment(alignLeft ? 'left' : 'center');
  }
  band(CK.ROWS.TITLE, 'Camera Kit', false);
  try{
    sh.getRange(CK.ROWS.REFRESH,1,1,aw).merge()
      .setValue('Refresh').setBackground('#E8E8E8').setFontColor('#333333')
      .setVerticalAlignment('middle').setHorizontalAlignment('center');
  }catch(_){}
  band(CK.ROWS.QE_HDR, 'Quantum Efficiency Curve', true);
  band(CK.ROWS.RIG_HDR, 'Rig Eligibility', true);
}

/* Seed first pair + IMX571 defaults */
function ck_seedFirstPairAndDefaults_(sh){
  // A3 control
  try{
    var dv = SpreadsheetApp.newDataValidation().requireValueInList(['Add Camera...', 'Cancel'], true).setAllowInvalid(true).build();
    sh.getRange(CK.ROWS.HEADERS, 1).setDataValidation(dv).setValue('Add Camera...').setHorizontalAlignment('left');
  }catch(_){}

  // Header for first pair
  try{ sh.getRange(CK.ROWS.HEADERS, 2, 1, 2).merge().setValue('Camera 1').setHorizontalAlignment('center'); }catch(_){}

  // Defaults (orange = attention)
  sh.getRange(CK.ROWS.CAMERA_MODEL, 2, 1, 2).merge().setValue('');
  sh.getRange(CK.ROWS.SENSOR_MODEL, 2, 1, 2).merge().setValue('Sony IMX571').setBackground(ck_orange());
  sh.getRange(CK.ROWS.PIXEL_SIZE,   2, 1, 2).merge().setValue(3.76).setBackground(ck_orange());
  try{ sh.getRange(CK.ROWS.SENSOR_SIZE, 2, 1, 2).breakApart(); }catch(_){}
  sh.getRange(CK.ROWS.SENSOR_SIZE, 2).setValue(6248).setBackground(ck_orange());
  sh.getRange(CK.ROWS.SENSOR_SIZE, 3).setValue(4176).setBackground(ck_orange());

  var q = [[CK.ROWS.QE_L_EDGE,400,0.2],[CK.ROWS.QE_L_INF,450,0.6],[CK.ROWS.QE_PEAK,530,0.8],[CK.ROWS.QE_U_INF,610,0.6],[CK.ROWS.QE_U_EDGE,680,0.2]];
  for (var i=0;i<q.length;i++){
    var row=q[i][0], lam=q[i][1], pct=q[i][2];
    try{ sh.getRange(row,2,1,2).breakApart(); }catch(_){}
    sh.getRange(row,2).setValue(lam).setBackground(ck_orange());
    sh.getRange(row,3).setValue(pct).setBackground(ck_orange());
  }
}

/* Rig triplets + FOV/Scale */
function ck_rebuildRigTripletsAndCompute_(sh){
  var aw = ck_aw_(sh), pairs = ck_pairs_(sh);
  if (!pairs.length) return;

  // Rig pairs from headers on 'Rig kit'
  var rigSh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSh) return;

  var rigPairs = [];
  var maxC = rigSh.getMaxColumns();
  for (var c=2;c<=maxC;c++){
    var nm = (rigSh.getRange(CK.ROWS.HEADERS, c).getDisplayValue()||'').trim();
    if (!nm) break;
    var m = rigSh.getRange(CK.ROWS.HEADERS, c).getMergedRanges();
    var w = (m && m.length) ? m[0].getWidth() : 2;
    rigPairs.push([c, c+w-1]);
    c += (w-1);
  }

  // Find focal length row (fallback heuristic)
  var focalRow = 0;
  var maxR = Math.min(200, rigSh.getMaxRows());
  for (var r=1; r<=maxR; r++){
    var label = (rigSh.getRange(r,1).getDisplayValue()||'').toLowerCase();
    if (label.indexOf('effective focal length')>=0 || (label.indexOf('focal')>=0 && label.indexOf('mm')>=0)){
      focalRow = r; break;
    }
  }

  // Paint + structure + compute
  for (var i=0;i<rigPairs.length;i++){
    var base = CK.ROWS.RIG_FIRST + i*3;
    try{ sh.getRange(base,1,3,aw).setBackground(COLORS.RigTint); }catch(_){}
    for (var p=0;p<pairs.length;p++){
      var cL = pairs[p][0];
      try{ sh.getRange(base+1, cL, 1, 2).breakApart(); }catch(_){}
      try{ sh.getRange(base+2, cL, 1, 2).merge(); }catch(_){}
      sh.getRange(base+1, cL, 1, 2).setHorizontalAlignment('center');
      sh.getRange(base+2, cL, 1, 2).setHorizontalAlignment('center');
    }
    if (focalRow){
      for (var p2=0;p2<pairs.length;p2++){
        var c0 = pairs[p2][0];
        var px  = parseFloat((sh.getRange(CK.ROWS.PIXEL_SIZE, c0).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
        var wpx = parseFloat((sh.getRange(CK.ROWS.SENSOR_SIZE, c0).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
        var hpx = parseFloat((sh.getRange(CK.ROWS.SENSOR_SIZE, c0+1).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
        if (isNaN(px)||isNaN(wpx)||isNaN(hpx)) continue;
        var fmm = parseFloat((rigSh.getRange(focalRow, rigPairs[i][0]).getDisplayValue()||'').replace(/[^0-9.\-eE]/g,''));
        if (!fmm) continue;
        var scale = 206.265 * px / fmm;       // arcsec/px
        var fovW  = (scale * wpx) / 60.0;     // arcmin
        var fovH  = (scale * hpx) / 60.0;
        sh.getRange(base+1, c0  ).setNumberFormat('0.0').setValue(fovW);
        sh.getRange(base+1, c0+1).setNumberFormat('0.0').setValue(fovH);
        sh.getRange(base+2, c0, 1, 2).merge().setNumberFormat('0.000').setValue(scale);
      }
    }
  }
}

/* onEdit helper (call from your router) */
function ck_onEditYellowAdjust_(e){
  try{
    var sh = e && e.range && e.range.getSheet ? e.range.getSheet() : null;
    if (!sh || sh.getName() !== CK.NAME) return;
    var r = e.range.getRow();
    var mergedRows = [CK.ROWS.CAMERA_MODEL, CK.ROWS.SENSOR_MODEL, CK.ROWS.PIXEL_SIZE, CK.ROWS.COOL_DELTA, CK.ROWS.UNITY_GAIN, CK.ROWS.READ_NOISE, CK.ROWS.DARK_CURRENT, CK.ROWS.FWC];
    var splitRows  = [CK.ROWS.SENSOR_SIZE, CK.ROWS.QE_L_EDGE, CK.ROWS.QE_L_INF, CK.ROWS.QE_PEAK, CK.ROWS.QE_U_INF, CK.ROWS.QE_U_EDGE];
    var target = (mergedRows.indexOf(r)>=0 || splitRows.indexOf(r)>=0 || r===CK.ROWS.COLOR);
    if (!target) return;
    var val = (e.value || '').toString().trim();
    if (!val){ if (!e.range.getBackground()) e.range.setBackground(ck_yellow()); }
    else{ if (e.range.getBackground() === ck_yellow()) e.range.setBackground(null); }
  }catch(_){}
}

/* Build entry — creates sheet if missing */
function buildCameraKit_(ss){
  ss = ss || SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(CK.NAME);
  if (!sh) sh = ss.insertSheet(CK.NAME);

  if (sh.getMaxRows() < 60) sh.insertRowsAfter(sh.getMaxRows(), 60 - sh.getMaxRows());

  ck_mergeBandsToActiveWidth_(sh);
  camerakit_enforcePairsAll_(sh);
  ck_applyColorDV_(sh);

  var pairs = ck_pairs_(sh);
  var firstHasSensor = sh.getRange(CK.ROWS.SENSOR_MODEL, 2).getDisplayValue();
  if (!pairs.length || !firstHasSensor){ ck_seedFirstPairAndDefaults_(sh); }

  ck_rebuildRigTripletsAndCompute_(sh);
  ck_paintMissingYellow_(sh);
}

/* Add Camera action */
function SkyPix_AddCamera_(){
  var sh = SpreadsheetApp.getActive().getSheetByName(CK.NAME);
  if (!sh) return;
  var aw = ck_aw_(sh);
  sh.insertColumnsAfter(aw, 2);
  var insertCol = aw + 1;
  sh.getRange(CK.ROWS.HEADERS, insertCol, 1, 2).merge().setValue('New Camera').setHorizontalAlignment('center');
  camerakit_enforcePairsAll_(sh);
  ck_applyColorDV_(sh);
  ck_rebuildRigTripletsAndCompute_(sh);
  ck_paintMissingYellow_(sh);
}



/*  =================================================  FILTER KIT  =================================================== */
/**
 * Build Filter Kit sheet with proper initial structure
 * REPLACES existing buildFilterKit_() function
 */
function buildFilterKit_(ss) {
  const sh = ss.getSheetByName(FK.NAME) || ss.insertSheet(FK.NAME, 4);
  sh.clear(); 
  sh.setName(FK.NAME);
  sh.setFrozenRows(5);
  const hpc = getHPC_Global_();
  while (sh.getMaxColumns() < 4) sh.insertColumnAfter(sh.getMaxColumns());
  
  // FIX: Set ALL columns B+ to same width (45px)
  sh.setColumnWidth(1, 160);
  sh.setColumnWidths(2, sh.getMaxColumns()-1, 45);
  
  sh.setRowHeights(1, sh.getMaxRows(), ROW_H_ALL);

   /* ----- ROW 1: TITLE ----- */
  mergeFullWidthRow_(sh, 1);
  const title = sh.getRange(1, 1);
  title.setValue('Filter Kit')
    .setBackground(hpcShade(hpc, 80))
    .setFontSize(TITLE_FS)
    .setFontWeight('bold')
    .setFontColor('#FFFFFF')
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');

  /* ----- ROW 2: REFRESH BAR ----- */
  // FIX: Correct dropdown choices
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh Rig Planners', 'Cancel']);

  /* ----- ROW 3: ADD FILTER DROPDOWN ----- */
  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setValue('Add Filter...')
    .setBackground(addBg)
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor('#FFFFFF')
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle')
    .setDataValidation(
      SpreadsheetApp.newDataValidation()
        .requireValueInList(['Add 1-band Filter', 'Add 2-band Filter', 'Add 3-band Filter', 'Add 4-band Filter', 'Cancel'], true)
        .setAllowInvalid(true)
        .build()
    );

  /* ----- ROW 3: FIRST FILTER HEADER (filter-wide merge) ----- */
  sh.getRange('B3:C3').merge()
    .setValue('Filter 1')
    .setBackground(hpcShade(hpc, 40))
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor('#FFFFFF')
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');

  /* ----- ROWS 4-13: FILTER LABELS ----- */
  const labels = [
    'Filter Model',        // 4
    'Band ID',            // 5
    'Bandwidth (nm)',     // 6
    'Peak Transmission (%)', // 7
    'Center Wavelength (nm)', // 8
    'Halo Performance',   // 9
    'Off-band Rejection (OD)', // 10
    'Filter Size (inch)', // 11
    'Parfocal Thickness (mm)', // 12
    'Glass Substrate'     // 13
  ];
  
  labels.forEach((label, i) => {
    leftLabel_(sh.getRange(4 + i, 1)).setValue(label).setWrap(true);
  });
  
  sh.getRange('B4:C4').merge()
  .setBackground(WARN_ORANGE)
  .setHorizontalAlignment('center')
  .setVerticalAlignment('middle')
  .setWrap(true);  // ADD THIS LINE

  /* ----- ROW 14: COLOR PICKER (filter-wide merge) ----- */
  leftLabel_(sh.getRange(14, 1)).setValue('Filter Highlight Color').setWrap(true);

  /* ----- ROW 15: ACKNOWLEDGE DEFAULTS (filter-wide merge) ----- */
  leftLabel_(sh.getRange(15, 1)).setValue('Acknowledge Defaults').setWrap(true);

  /* ----- FIX: Row 16 - BLANK SPACER (dynamic width) ----- */
  const width = 3; // Initial width (A, B, C)
  try {
    sh.getRange(16, 1, 1, sh.getMaxColumns()).breakApart();
  } catch(e) {}
  sh.getRange(16, 1, 1, width).merge();
  sh.getRange(16, 1).setValue('').setBackground(null);

  /* ----- ROW 17: TRANSMISSION CURVE HEADER ----- */
  mergeFullWidthRow_(sh, 17);
  sh.getRange(17, 1).setValue('Transmission Curve')
    .setBackground(hpcShade(hpc, 30))
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor(DARK_GREY_FONT)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');

  /* ----- ROWS 18-22: TRANSMISSION CURVE LABELS (5 rows, unmerged) ----- */
  const curveLabels = [
    'Lower edge',                        // 18
    'Lower inflection or quarter-point', // 19
    'Peak',                              // 20
    'Upper inflection or quarter-point', // 21
    'Upper edge'                         // 22
  ];
  
  curveLabels.forEach((label, i) => {
    const row = 18 + i;  // Explicit: rows 18, 19, 20, 21, 22
    leftLabel_(sh.getRange(row, 1)).setValue(label).setWrap(true);
    Logger.log(`Curve label row ${row}: ${label}`);
  });

  /* ----- FIX: Row 23 - BLANK SPACER (dynamic width) ----- */
  const activeWidth = getActiveWidth_(sh);
  try {
    sh.getRange(23, 1, 1, sh.getMaxColumns()).breakApart();
  } catch(e) {}
  sh.getRange(23, 1, 1, activeWidth).merge();
  sh.getRange(23, 1).setValue('').setBackground(null);

  /* ----- ROW 24: RIG ELIGIBILITY HEADER ----- */
  mergeFullWidthRow_(sh, 24);
  sh.getRange(24, 1).setValue('Rig Eligibility')
    .setBackground(hpcShade(hpc, 30))
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor(DARK_GREY_FONT)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');

  /* ----- INITIAL FILTER 1 DATA (1-band, Band ID = L) ----- */
  // Row 4: Filter Model (filter-wide merge)
  sh.getRange('B4:C4').merge()
    .setBackground(WARN_ORANGE)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');
  
  // FIX: Per-band pair merging for rows 5-13
  [5, 6, 7, 8, 9, 10, 11, 12, 13].forEach(row => {
    sh.getRange(row, 2, 1, 2).merge()
      .setBackground(WARN_ORANGE)
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle');
  });

  // Band ID dropdown (row 5)
  const bandDv = SpreadsheetApp.newDataValidation()
    .requireValueInList(FILTER_BAND_TYPES, true)
    .setAllowInvalid(true)
    .build();
  sh.getRange('B5:C5').setDataValidation(bandDv).setValue('L');

// FIX: Populate defaults for L band (rows 6-13)
populateDefaultBandData_(sh, 2, 'L');

// Row 14: Color picker (filter-wide merge) - default to HPC background, no text
sh.getRange('B14:C14').merge()
  .setBackground(hpc)  // Set background to HPC color
  .setDataValidation(SpreadsheetApp.newDataValidation()
    .requireValueInList(COLOR_PICKER.map(r=>r[0]), true)
    .setAllowInvalid(true)
    .build())
  .setValue('');  // No text, just color

sh.getRange('B15:C15').merge()
  .insertCheckboxes()
  .setHorizontalAlignment('center')
  .setVerticalAlignment('middle');

// FIX: Populate transmission curve defaults for L band (rows 18-22)
populateTransmissionCurve_(sh, 2, 'L');

// Paint transmission curve orange
sh.getRange(18, 2, 5, 2).setBackground(WARN_ORANGE);

  centerAllColumns_(sh);
  recolorFilterKitBands_(sh);

  SpreadsheetApp.getActive().toast('Filter added.');
  
  
  centerAllColumns_(sh);
  addFilterKitNotes_(sh);  // ADD THIS
  recolorFilterKitBands_(sh);
  applyFilterBandColors_(sh);
  
  // Build rig eligibility if Rig Kit exists
  const rigSheet = ss.getSheetByName('Rig kit');
  if (rigSheet) {
    const rigs = _rigkit_getRigSpecs_(rigSheet);
    Logger.log('Rigs found during build: ' + (rigs ? rigs.length : 0));
    if (rigs && rigs.length > 0) {
      rebuildRigEligibility_Filter_Fixed_(sh, rigs);
    }
  }
}

function addFilterKitNotes_(sh) {
  // Rows 4-13: Filter data characteristics
  sh.getRange('A4').setNote('Enter the manufacturer and model name of this filter');
  sh.getRange('A5').setNote('Select the emission line or broadband type (Ha, OIII, SII, L, R, G, B, etc.)');
  sh.getRange('A6').setNote('Full width at half maximum (FWHM) of the filter passband in nanometers');
  sh.getRange('A7').setNote('Maximum transmission percentage at the peak wavelength');
  sh.getRange('A8').setNote('Center wavelength of the filter passband in nanometers');
  sh.getRange('A9').setNote('Filter performance regarding halo artifacts around bright stars');
  sh.getRange('A10').setNote('Out-of-band light rejection measured in optical density (OD) units');
  sh.getRange('A11').setNote('Physical diameter of the filter (1.25", 2", 36mm, etc.)');
  sh.getRange('A12').setNote('Thickness of the filter cell for parfocal imaging');
  sh.getRange('A13').setNote('Type of glass substrate used in filter construction');
  
  // Rows 18-22: Transmission curve points
  sh.getRange('A18').setNote('Wavelength (nm) and transmission (%) at the lower edge of the passband');
  sh.getRange('A19').setNote('Wavelength (nm) and transmission (%) at the lower quarter-point or inflection');
  sh.getRange('A20').setNote('Wavelength (nm) and transmission (%) at peak transmission');
  sh.getRange('A21').setNote('Wavelength (nm) and transmission (%) at the upper quarter-point or inflection');
  sh.getRange('A22').setNote('Wavelength (nm) and transmission (%) at the upper edge of the passband');
}



/**
 * Rebuild Filter Kit layout with new structure:
 * - Transmission Curve BEFORE Rig Eligibility
 * - 5-row curve (Lower edge, Lower qtr, Peak, Upper qtr, Upper edge)
 * - Dynamic blank rows for visual separation
 */
function rebuildFilterKitLayout_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Filter Kit');
  if (!sh) return;
  
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);
  
  // Buffer existing transmission curve data BEFORE clearing
  const curveBuffer = bufferTransmissionCurveData_(sh);
  const rigBuffer = bufferFilterRigCheckboxes_(sh, 25, 10); // Buffer rig checkboxes
  
  // Delete everything below row 15 (Acknowledge Defaults)
  const lastRow = sh.getLastRow();
  if (lastRow > 15) {
    sh.deleteRows(16, lastRow - 15);
  }
  
  // Insert rows for new structure
  sh.insertRowsAfter(15, 30);
  sh.setRowHeights(16, 30, ROW_H_ALL);
  
  /* ----- ROW 16: BLANK SPACER ----- */
  mergeFullWidthRow_(sh, 16);
  sh.getRange(16, 1).setValue('').setBackground(null);
  
  /* ----- ROW 17: TRANSMISSION CURVE SUBHEADER ----- */
  mergeFullWidthRow_(sh, 17);
  const curveHdr = sh.getRange(17, 1);
  curveHdr.setValue('Transmission Curve')
    .setBackground(hpcShade(hpc, 30))
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor(DARK_GREY_FONT)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');
  
  /* ----- ROWS 18-22: TRANSMISSION CURVE DATA (5 ROWS) ----- */
  const curveLabels = [
    'Lower edge',
    'Lower inflection or quarter-point',
    'Peak',
    'Upper inflection or quarter-point',
    'Upper edge'
  ];
  
  curveLabels.forEach((label, i) => {
    const row = 18 + i; // Start at row 18
    const labelCell = sh.getRange(row, 1);
    leftLabel_(labelCell).setValue(label).setWrap(true);
  });
  
  // Add λ/% helper labels for each band of each filter
  const filterBlocks = getFilterBlocks_(sh);
  filterBlocks.forEach(block => {
    const numBands = block.width / 2;
    for (let b = 0; b < numBands; b++) {
      const col = block.startCol + (b * 2);
      sh.getRange(18, col).setValue('λ nm').setFontSize(8).setHorizontalAlignment('center');
      sh.getRange(18, col + 1).setValue('%').setFontSize(8).setHorizontalAlignment('center');
    }
  });
  
  // Restore buffered curve data to new location (row 18)
  restoreTransmissionCurveData_(sh, curveBuffer, 18);
  
  /* ----- ROW 23: BLANK SPACER ----- */
  mergeFullWidthRow_(sh, 23);
  sh.getRange(23, 1).setValue('').setBackground(null);
  
  /* ----- ROW 24: RIG ELIGIBILITY SUBHEADER ----- */
  mergeFullWidthRow_(sh, 24);
  const eligHdr = sh.getRange(24, 1);
  eligHdr.setValue('Rig Eligibility')
    .setBackground(hpcShade(hpc, 30))
    .setFontSize(HEADER_FS)
    .setFontWeight('bold')
    .setFontColor(DARK_GREY_FONT)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');
  
  /* ----- ROWS 25+: RIG ELIGIBILITY MATRIX ----- */
  // FIX: Rebuild rig eligibility from existing Rig Kit (row 25+)
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (rigSheet) {
    const rigs = _rigkit_getRigSpecs_(rigSheet);
    if (rigs && rigs.length > 0) {
      rebuildRigEligibility_Filter_Fixed_(sh, rigs);
    }
  }

  centerAllColumns_(sh);
  recolorFilterKitBands_(sh);
  applyFilterBandColors_(sh);  // <-- ADD THIS LINE

  SpreadsheetApp.getActive().toast('Filter added.');
  
}

/**
 * Buffer transmission curve data before restructure
 */
function bufferTransmissionCurveData_(sh) {
  const buffer = [];
  const filterBlocks = getFilterBlocks_(sh);
  
  // Find old curve location
  const oldCurveHdr = findRowWithText_(sh, 'Transmission Curve');
  if (!oldCurveHdr) return buffer; // No existing curves
  
  const oldCurveStart = oldCurveHdr + 2; // Skip header + λ/% row
  
  filterBlocks.forEach(block => {
    const numBands = block.width / 2;
    const blockCurves = [];
    
    for (let b = 0; b < numBands; b++) {
      const col = block.startCol + (b * 2);
      
      // Read up to 10 rows of curve data
      const curveData = sh.getRange(oldCurveStart, col, 10, 2).getValues();
      blockCurves.push(curveData);
    }
    
    buffer.push(blockCurves);
  });
  
  return buffer;
}

/**
 * Restore transmission curve data to new location
 */
function restoreTransmissionCurveData_(sh, buffer, newStartRow) {
  if (!buffer || buffer.length === 0) return;
  
  const filterBlocks = getFilterBlocks_(sh);
  
  filterBlocks.forEach((block, idx) => {
    if (idx >= buffer.length) return;
    
    const blockCurves = buffer[idx];
    const numBands = block.width / 2;
    
    for (let b = 0; b < numBands && b < blockCurves.length; b++) {
      const col = block.startCol + (b * 2);
      const curveData = blockCurves[b];
      
      // Write EXACTLY 5 rows starting at newStartRow (18)
      const rowsToWrite = Math.min(5, curveData.length);
      if (rowsToWrite > 0) {
        sh.getRange(newStartRow, col, rowsToWrite, 2)
          .setValues(curveData.slice(0, rowsToWrite));
      }
    }
  });
}

function SkyPix_AddFilter_(command) {
  const sh = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  if (!sh) return;

  const numBands = parseInt((command || '').replace(/[^0-9]/g, ''), 10);
  if (isNaN(numBands) || numBands < 1) return;

  const defaultBands = numBands === 1 ? ['L'] : 
                       numBands === 2 ? ['Ha', 'OIII'] : 
                       numBands === 3 ? ['Ha', 'OIII', 'SII'] : 
                       numBands === 4 ? ['Ha', 'Hb', 'OIII', 'SII'] : 
                       Array(numBands).fill('Ha');
  
  const startCol = getActiveWidth_(sh) + 1;
  const numCols = numBands * 2;

  let filterBlocks = getFilterBlocks_(sh);
  let nextFilterNum = filterBlocks.length + 1;

  sh.insertColumnsAfter(startCol - 1, numCols);
  
  // FIX: Set all new columns to same width
  sh.setColumnWidths(startCol, numCols, 45);

  const hpc = getHPC_Global_();
  const newWidth = startCol + numCols - 1;

  // FIX: Expand dynamic rows to new width (including 16 and 23)
  [1, 2, 16, 17, 23, 24].forEach(row => {
    try {
      sh.getRange(row, 1, 1, sh.getMaxColumns()).breakApart();
    } catch(e) {}
    sh.getRange(row, 1, 1, newWidth).merge();
  });

  // Filter header (row 3) - filter-wide merge
  sh.getRange(3, startCol, 1, numCols).merge()
    .setValue(`Filter ${nextFilterNum}`)
    .setBackground(hpcShade(hpc, 40))
    .setFontWeight('bold')
    .setFontSize(HEADER_FS)
    .setFontColor('#FFFFFF')
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle');

  // Row 4: Filter-wide merge for this filter
  sh.getRange(4, startCol, 1, numCols).merge()
    .setBackground(WARN_ORANGE)
    .setHorizontalAlignment('center')
    .setVerticalAlignment('middle')
    .setWrap(true); 
  // FIX: Per-band merging for data rows 5-13
for (let b = 0; b < numBands; b++) {
  const bandCol = startCol + (b * 2);
  
  // Rows 5-13: merge per band pair
  [5, 6, 7, 8, 9, 10, 11, 12, 13].forEach(row => {
    sh.getRange(row, bandCol, 1, 2).merge()
      .setBackground(WARN_ORANGE)
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle');
  });

  // Row 5: Band ID with dropdown
  const bandDv = SpreadsheetApp.newDataValidation()
    .requireValueInList(FILTER_BAND_TYPES, true)
    .setAllowInvalid(true)
    .build();
  
  sh.getRange(5, bandCol, 1, 2).setDataValidation(bandDv).setValue(defaultBands[b]);
  
  // Populate defaults for this band
  populateDefaultBandData_(sh, bandCol, defaultBands[b]);
  
  // Populate transmission curve for this band (rows 18-22)
  populateTransmissionCurve_(sh, bandCol, defaultBands[b]);
  
  // Paint transmission curve orange (rows 18-22)
  sh.getRange(18, bandCol, 5, 2).setBackground(WARN_ORANGE);
}

// Row 14: Color picker (filter-wide merge) - default to HPC background, no text
sh.getRange(14, startCol, 1, numCols).merge()
  .setBackground(hpc)  // Set background to HPC color
  .setDataValidation(SpreadsheetApp.newDataValidation()
    .requireValueInList(COLOR_PICKER.map(r=>r[0]), true)
    .setAllowInvalid(true)
    .build())
  .setValue('');  // No text, just color

// Row 15: Acknowledge Defaults (filter-wide merge) - AFTER the loop
sh.getRange(15, startCol, 1, numCols).merge()
  .insertCheckboxes()
  .setHorizontalAlignment('center')
  .setVerticalAlignment('middle');
  // FIX: Rebuild rig eligibility from existing Rig Kit (row 25+)
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (rigSheet) {
    const rigs = _rigkit_getRigSpecs_(rigSheet);
    if (rigs && rigs.length > 0) {
      rebuildRigEligibility_Filter_Fixed_(sh, rigs);
    }
  }

  // FIX: Apply borders to all band pairs
  applyFilterBandBorders_(sh);

  centerAllColumns_(sh);
  recolorFilterKitBands_(sh);
  applyFilterBandBorders_(sh);
  SpreadsheetApp.getActive().toast('Filter added.');
}


function centerAllColumns_(sh) {
  const width = getActiveWidth_(sh);
  if (width > 1) {
    sh.getRange(1, 2, sh.getMaxRows(), width - 1).setHorizontalAlignment('center').setVerticalAlignment('middle');
  }
}

function populateDefaultBandData_(sh, filterCol, bandType) {
  const band = (bandType || '').trim();
  const defaults = FILTER_DEFAULTS[band];
  if (!defaults) return;
  
  // FIX: Populate ALL characteristics (rows 6-13)
  sh.getRange(6, filterCol, 1, 2).setValue(defaults.bandwidth);        // Bandwidth
  sh.getRange(7, filterCol, 1, 2).setValue(defaults.peak);             // Peak Transmission
  sh.getRange(8, filterCol, 1, 2).setValue(defaults.cwl);              // Center Wavelength
  sh.getRange(9, filterCol, 1, 2).setValue(defaults.halo);             // Halo Performance
  sh.getRange(10, filterCol, 1, 2).setValue(defaults.rejection);       // Off-band Rejection
  sh.getRange(11, filterCol, 1, 2).setValue(defaults.filterSize);      // Filter Size
  sh.getRange(12, filterCol, 1, 2).setValue(defaults.thickness);       // Thickness
  sh.getRange(13, filterCol, 1, 2).setValue(defaults.substrate);       // Substrate
}

function applyFilterBandBorders_(sh) {
  const filterBlocks = getFilterBlocks_(sh);
  Logger.log(`=== APPLYING BORDERS: ${filterBlocks.length} filters found ===`);
  
  if (!filterBlocks || filterBlocks.length === 0) return;
  
  const borderColor = DARK_GREY_FONT;
  const border1px = SpreadsheetApp.BorderStyle.SOLID;
  const border2px = SpreadsheetApp.BorderStyle.SOLID_MEDIUM;
  
  filterBlocks.forEach((block, idx) => {
    Logger.log(`Filter ${idx + 1}: startCol=${block.startCol}, width=${block.width}`);
    const numBands = block.width / 2;
    const filterEndCol = block.startCol + block.width - 1;
    
    // Rows 3-15: Filter data section borders
    for (let row = 3; row <= 15; row++) {
      // 2px border on right edge of entire filter
      sh.getRange(row, filterEndCol)
        .setBorder(null, null, null, true, null, null, borderColor, border2px);
      
      // For rows 5-13 (band data), add 1px borders between band pairs
      if (row >= 5 && row <= 13) {
        for (let b = 0; b < numBands - 1; b++) {
          const bandPairEndCol = block.startCol + (b * 2) + 1;
          sh.getRange(row, bandPairEndCol)
            .setBorder(null, null, null, true, null, null, borderColor, border1px);
        }
      }
    }
    
    // Rows 18-22: Transmission curve borders (same pattern)
    for (let row = 18; row <= 22; row++) {
      sh.getRange(row, filterEndCol)
        .setBorder(null, null, null, true, null, null, borderColor, border2px);
      
      for (let b = 0; b < numBands - 1; b++) {
        const bandPairEndCol = block.startCol + (b * 2) + 1;
        sh.getRange(row, bandPairEndCol)
          .setBorder(null, null, null, true, null, null, borderColor, border1px);
      }
    }
  });
  
// Apply 2px borders to rig eligibility section (row 25+)
  const eligStartRow = 25;
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (rigSheet) {
    const rigs = _rigkit_getRigSpecs_(rigSheet);
    
    // Border on right edge of each filter column
    filterBlocks.forEach(block => {
      const filterEndCol = block.startCol + block.width - 1;
      for (let r = 0; r < rigs.length; r++) {
        const row = eligStartRow + r;
        sh.getRange(row, filterEndCol)
          .setBorder(null, null, null, true, null, null, borderColor, border2px);
      }
    });
    
    // Border on right edge of column A for rig section
    sh.getRange(eligStartRow, 1, rigs.length, 1)
      .setBorder(null, null, null, true, null, null, borderColor, border2px);
  }
  
  // 2px border on right edge of column A (rows 3-22)
  sh.getRange(3, 1, 20, 1).setBorder(null, null, null, true, null, null, borderColor, border2px);
}

 /* FILTER KIT: Rebuild rig eligibility with proper 30% HPC shading */
 
function rebuildRigEligibility_Filter_Fixed_(sh, rigs) {
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSheet) return;
  
  // Get rigs if not provided
  if (!rigs || rigs.length === 0) {
    rigs = _rigkit_getRigSpecs_(rigSheet);
  }
  
  if (!rigs || !rigs.length) return;
  
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);
  const eligHeader = 24;
  const startRow = 25;
  
  // Clear old rig rows
  const clearRows = Math.max(rigs.length + 5, 10);
  if (startRow + clearRows <= sh.getMaxRows()) {
    sh.getRange(startRow, 1, clearRows, width)
      .clearContent()
      .removeCheckboxes()
      .setBackground(null)
      .setFontWeight('normal')
      .setFontColor(DARK_GREY_FONT);
  }
  
  const filterBlocks = getFilterBlocks_(sh);
  
  rigs.forEach((rig, i) => {
    const row = startRow + i;
    
    // FIX: Apply 30% HPC shade across FULL active width
    const rigColor = rig.color || hpc;
    const shadedColor = hpcShade(rigColor, 30);
    
    // Set rig name
    leftLabel_(sh.getRange(row, 1)).setValue(rig.name);
    
    // FIX: Paint entire row with 30% shade
    sh.getRange(row, 1, 1, width)
      .setBackground(shadedColor)
      .setFontColor(DARK_GREY_FONT);
    
    // Add filter-wide merged checkbox for each filter
    filterBlocks.forEach(block => {
      sh.getRange(row, block.startCol, 1, block.width)
        .merge()
        .insertCheckboxes()
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle');
    });
  });
  
  // ADD THIS: Apply borders to rig eligibility section
  const borderColor = DARK_GREY_FONT;
  const border2px = SpreadsheetApp.BorderStyle.SOLID_MEDIUM;
  
  filterBlocks.forEach(block => {
    const filterEndCol = block.startCol + block.width - 1;
    for (let r = 0; r < rigs.length; r++) {
      const row = startRow + r;
      sh.getRange(row, filterEndCol)
        .setBorder(null, null, null, true, null, null, borderColor, border2px);
    }
  });
  
  // Column A right border for rig section
  sh.getRange(startRow, 1, rigs.length, 1)
    .setBorder(null, null, null, true, null, null, borderColor, border2px);
}


/**
 * Buffer existing Filter Kit checkbox states
 */
function bufferFilterRigCheckboxes_(filterSh, startRow, numRigs) {
  const buffer = [];
  const filterBlocks = getFilterBlocks_(filterSh);
  
  for (let i = 0; i < numRigs; i++) {
    const row = startRow + i;
    const checkboxStates = [];
    
    filterBlocks.forEach(block => {
      try {
        const val = filterSh.getRange(row, block.startCol).getValue();
        checkboxStates.push(val === true);
      } catch(e) {
        checkboxStates.push(false);
      }
    });
    
    buffer.push(checkboxStates);
  }
  
  return buffer;
}

function getFilterBlocks_(sh) {
  const width = getActiveWidth_(sh), blocks = [];
  if (width < 2) return blocks;
  let c = 2;
  while (c <= width) {
    const headCell = sh.getRange(3, c);
    if (headCell.getDisplayValue().startsWith('Filter')) {
      const merged = headCell.getMergedRanges()[0];
      const blockWidth = merged ? merged.getWidth() : 2;
      blocks.push({ startCol: c, width: blockWidth });
      c += blockWidth;
    } else {
      c++;
    }
  }
  return blocks;
}

function getFilterBlockForColumn_(sh, col) {
  return getFilterBlocks_(sh).find(block => col >= block.startCol && col < block.startCol + block.width);
}

function getRigData_() {
  const rigSheet = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!rigSheet || getActiveWidth_(rigSheet) < 2) {
    return [{ name: 'Rig 1 (Default)', color: DEFAULT_HPC }];
  }

  const hdrRow = 3;
  const width  = getActiveWidth_(rigSheet);
  const headerVals = rigSheet.getRange(hdrRow, 2, 1, width - 1).getDisplayValues()[0];
  const rigNames = [];
  for (let i = 0; i < headerVals.length; i += 2) {
    const name = String(headerVals[i] || '').trim();
    if (name) rigNames.push(name);
  }
  if (rigNames.length === 0) return [{ name: 'Rig 1 (Default)', color: DEFAULT_HPC }];

  const colorRow = findRowWithText_(rigSheet, 'Rig highlight color');
  let bgRow = [];
  if (colorRow) {
    bgRow = rigSheet.getRange(colorRow, 2, 1, rigNames.length * 2).getBackgrounds()[0];
  }

  return rigNames.map((name, i) => ({
    name,
    color: bgRow[i * 2] || DEFAULT_HPC
  }));
}

function findRowWithText_(sh, text) {
  const f = sh.createTextFinder(text).findNext();
  return f ? f.getRow() : null;
}

function recolorFilterKitBands_(sh) {
  if (!sh) return;
  const hpc = getHPC_Global_();
  const width = getActiveWidth_(sh);

  const title = sh.getRange(1, 1, 1, width).merge().setBackground(hpcShade(hpc, 80));
  styleSubheader_(title, '#FFFFFF').setFontSize(TITLE_FS);

  const addCell = sh.getRange('A3');
  const addBg = hpcShade(hpc, 20);
  addCell.setBackground(addBg);
  styleSubheader_(addCell, '#FFFFFF');
  stylePaddedCell_(addCell, 'Add Filter...', addBg, '#FFFFFF', true);

  if (width > 1) {
    const headers = sh.getRange(3, 2, 1, width - 1).setBackground(hpcShade(hpc, 40));
    styleSubheader_(headers, '#FFFFFF');
  }

  const eligHeaderRow = 24;
  const curveHeaderRow = 17;
  
  sh.getRange(eligHeaderRow, 1).setBackground(hpcShade(hpc, 30));
  sh.getRange(curveHeaderRow, 1).setBackground(hpcShade(hpc, 30));

  sh.getRange('A4:A15').setHorizontalAlignment('left').setVerticalAlignment('middle').setWrap(true);
  sh.getRange(1, 1, sh.getFrozenRows(), width).setBorder(true, true, true, true, null, true, hpcShade(hpc, 40), SpreadsheetApp.BorderStyle.SOLID);
  
  // FIX: Correct refresh choices
  writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, ['Refresh Rig Planners', 'Cancel']);
}
  
  
function applyFilterBorders_(sh, filterBlocks) {
  if (!filterBlocks || filterBlocks.length === 0) return;
  const borderColor = hpcShade(getHPC_Global_(), 75);
  const lastRow = 30;
  filterBlocks.forEach(block => {
    sh.getRange(FK.ROWS.MODEL, block.startCol, lastRow - FK.ROWS.MODEL + 1, block.width)
      .setBorder(null, true, null, true, null, null, borderColor, SpreadsheetApp.BorderStyle.SOLID_MEDIUM);
  });
}

function rebuildRigEligibility_Filter_(rigData, filterBlocks) {
  const sh = SpreadsheetApp.getActive().getSheetByName(FK.NAME);
  if (!sh || !rigData || rigData.length === 0 || !filterBlocks) return;
  const startRow = findRowWithText_(sh, 'Rig Eligibility') + 1;
  const width = getActiveWidth_(sh);

  rigData.forEach((rig, i) => {
    const row = startRow + i;
    leftLabel_(sh.getRange(row, 1)).setValue(rig.name);
    const rigHex = normalizeHexOrName_(rig.color);
    sh.getRange(row, 1, 1, width)
      .setBackground(rigHex)
      .setFontColor(hexIsDark_(rigHex) ? '#FFFFFF' : '#000000');

    filterBlocks.forEach(block => {
      sh.getRange(row, block.startCol, 1, block.width).merge().insertCheckboxes().setHorizontalAlignment('center');
    });
  });
}

function rebuildTransmissionCurve_(sh, curveHeaderRow, filterBlocks) {
  if (!curveHeaderRow || !filterBlocks) return;
  const helperRow = curveHeaderRow + 1;
  filterBlocks.forEach(block => {
    for (let i = 0; i < (block.width / 2); i++) {
      const bandCol = block.startCol + (i * 2);
      sh.getRange(helperRow, bandCol).setValue('λ').setHorizontalAlignment('center').setFontWeight('bold');
      sh.getRange(helperRow, bandCol + 1).setValue('%').setHorizontalAlignment('center').setFontWeight('bold');
    }
  });
}

function populateTransmissionCurve_(sh, bandCol, bandType) {
  const band = (bandType || '').trim();
  const curveData = TRANSMISSION_CURVE_DEFAULTS[band];
  if (!curveData || curveData.length !== 5) {
    Logger.log(`Transmission curve: No data for band ${band}`);
    return;
  }
  
  // WORKAROUND: Start at row 17 to compensate for mysterious 1-row offset
  // Loop: i=0 -> row 17, i=1 -> row 18, i=2 -> row 19, i=3 -> row 20, i=4 -> row 21
  // Start at row 18 where the labels actually are
  for (let i = 0; i < 5; i++) {
    const row = 18 + i;  // Rows: 18, 19, 20, 21, 22 (matches the labels)
    sh.getRange(row, bandCol).setValue(curveData[i][0]);       // λ (nm)
    sh.getRange(row, bandCol + 1).setValue(curveData[i][1]);   // % transmission
    
    Logger.log(`Curve row ${row}: λ=${curveData[i][0]}, %=${curveData[i][1]} at col ${bandCol}`);
  }

  // Paint orange for rows 18-22 (not 17-21)
  sh.getRange(18, bandCol, 5, 2).setBackground(WARN_ORANGE);
  Logger.log(`Populated transmission curve for ${band} starting at row 18, col ${bandCol}`);
}

function handlePlannerUpdate_() {
  const ss = SpreadsheetApp.getActive();
  const plannerSheets = ss.getSheets().filter(s => s.getName().endsWith('Planner'));
  if (plannerSheets.length === 0) {
    ss.toast('No Rig Planners found to update.');
    return;
  }
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt('Update Rig Planner', 'Enter name of Rig Planner to update:', ui.ButtonSet.OK_CANCEL);
  if (response.getSelectedButton() == ui.Button.OK) {
    const selectedPlanner = response.getResponseText();
    if (plannerSheets.map(s => s.getName()).indexOf(selectedPlanner) > -1) {
      ss.toast(`Updating ${selectedPlanner}... (feature under construction)`);
    } else {
      ui.alert(`Sheet "${selectedPlanner}" is not a valid Rig Planner.`);
    }
  }
}

function populateTransmissionCurve_(sh, bandCol, bandType) {
  const band = (bandType || '').trim();
  const curveData = TRANSMISSION_CURVE_DEFAULTS[band];
  if (!curveData || curveData.length !== 5) {
    Logger.log(`Transmission curve: No data for band ${band}`);
    return;
  }
  
  // DIAGNOSTIC: What's in row 18 right now?
  Logger.log(`=== TRANSMISSION CURVE DEBUG ===`);
  Logger.log(`Band: ${band}, Column: ${bandCol}`);
  Logger.log(`Row 18 current value: "${sh.getRange(18, 1).getValue()}"`);
  Logger.log(`Row 19 current value: "${sh.getRange(19, 1).getValue()}"`);
  
  // Write data starting at row 18
  for (let i = 0; i < 5; i++) {
    const row = 18 + i;
    sh.getRange(row, bandCol).setValue(curveData[i][0]);
    sh.getRange(row, bandCol + 1).setValue(curveData[i][1]);
    Logger.log(`Wrote to row ${row}: λ=${curveData[i][0]}, %=${curveData[i][1]}`);
  }
}

function handlePlannerUpdate_() {
  const ss = SpreadsheetApp.getActive();
  const plannerSheets = ss.getSheets().filter(s => s.getName().endsWith('Planner'));
  if (plannerSheets.length === 0) {
    ss.toast('No Rig Planners found to update.');
    return;
  }
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt('Update Rig Planner', 'Enter name of Rig Planner to update:', ui.ButtonSet.OK_CANCEL);
  if (response.getSelectedButton() == ui.Button.OK) {
    const selectedPlanner = response.getResponseText();
    if (plannerSheets.map(s => s.getName()).indexOf(selectedPlanner) > -1) {
      ss.toast(`Updating ${selectedPlanner}... (feature under construction)`);
    } else {
      ui.alert(`Sheet "${selectedPlanner}" is not a valid Rig Planner.`);
    }
  }
}

// --- Object Entry & Database Modules ---
function buildObjectDatabase_(ss) {
  const sh = ss.getSheetByName("Object Database") || ss.insertSheet("Object Database", 5);
  try {
    sh.clear(); sh.setName("Object Database");
    sh.setFrozenRows(0); sh.setFrozenColumns(0);
    setObjectDatabaseColumnWidths(sh);
    createObjectDatabaseTitleBanner(sh);
    createObjectDatabaseLayout_V3(sh);
    sh.setRowHeights(5, sh.getMaxRows() - 4, 36);
    sh.setFrozenRows(4);
  } catch (error) {
    logDebug_(`Header creation failed: ${error.toString()}`);
    SpreadsheetApp.getUi().alert(`Error building database: ${error.message}`);
  }
  sh.getRange('A5:A').setDataValidation(SpreadsheetApp.newDataValidation().requireValueInList(['Smart Search with emission profile update', 'Smart Search with Notes update']).setAllowInvalid(true).setHelpText('Enter an Object ID, or select a Smart Search option.').build());
}

function setObjectDatabaseColumnWidths(sheet) {
  const totalCols = 26;
  const maxCols = sheet.getMaxColumns();
  if (maxCols > totalCols) sheet.deleteColumns(totalCols + 1, maxCols - totalCols);
  if (maxCols < totalCols) sheet.insertColumnsAfter(maxCols, totalCols - maxCols);
  
  const widths = {1: 80, 2: 150, 3: 60, 4: 60, 5: 50, 6: 50, 7: 100, 8: 100};
  for (let col in widths) sheet.setColumnWidth(parseInt(col), widths[col]);
  for (let i = 9; i <= 26; i++) sheet.setColumnWidth(i, 50);
}

function createObjectDatabaseTitleBanner(sheet) {
  const baseColor = getHPC_Global_();
  sheet.getRange('A1:Z1').merge().setValue('Object Database').setBackground(hpcShade(baseColor, 80)).setFontSize(TITLE_FS).setFontWeight('bold').setFontColor('#FFFFFF').setHorizontalAlignment('center').setVerticalAlignment('middle').setBorder(true, true, true, true, true, true, hpcShade(baseColor, 40), SpreadsheetApp.BorderStyle.SOLID);
}

function createObjectDatabaseLayout_V3(sheet) {
  const baseColor = getHPC_Global_();
  const borderColor = hpcShade(baseColor, 40);

  sheet.setRowHeight(1, 36).setRowHeight(2, 36).setRowHeights(3, 2, 25);

  const applyFormatting = (range, label, color) => {
    range.setValue(label).setBackground(color).setFontSize(10).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('bottom').setWrap(true).setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  };
  
  const sectionHeaders = [{ range: 'A2:H2', label: 'Objects', color: hpcShade(baseColor, 45) }, { range: 'J2:M2', label: 'Emission Profile', color: hpcShade(baseColor, 30) }, { range: 'O2:Z2', label: 'Home Site Transit', color: hpcShade(baseColor, 15) }];
  sectionHeaders.forEach(header => {
    sheet.getRange(header.range).merge().setValue(header.label).setBackground(header.color).setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID).setFontSize(12).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('middle');
  });

  const emissionColor = hpcShade(baseColor, 30);
  const smRange = sheet.getRange('I2:I4').merge();
  applyFormatting(smRange, 'Surface Magnitude', emissionColor);
  smRange.setTextRotation(90).setVerticalAlignment('middle');
  const esRange = sheet.getRange('N2:N4').merge();
  applyFormatting(esRange, 'Exposure Strategy', emissionColor);
  esRange.setTextRotation(90).setVerticalAlignment('middle');

  const objectColor = hpcShade(baseColor, 45);
  [{ range: 'A3:A4', label: 'Object ID' }, { range: 'B3:B4', label: 'Object Name' }, { range: 'C3:C4', label: 'RA' }, { range: 'D3:D4', label: 'Dec' }, { range: 'G3:G4', label: 'Image URL' }, { range: 'H3:H4', label: 'Notes' }].forEach(field => { applyFormatting(sheet.getRange(field.range).merge(), field.label, objectColor); });
  [{ range: 'J3:J4', label: 'Ha %' }, { range: 'K3:K4', label: 'OIII %' }, { range: 'L3:L4', label: 'SII %' }, { range: 'M3:M4', label: 'Broadband %' }].forEach(field => { applyFormatting(sheet.getRange(field.range).merge(), field.label, emissionColor); });

  const transitColor = hpcShade(baseColor, 15);
  ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].forEach((month, i) => {
    applyFormatting(sheet.getRange(3, 15 + i, 2, 1).merge(), month, transitColor);
  });

  const sizeColor = hpcShade(baseColor, 45);
  sheet.getRange('E3:F3').merge().setValue('Size (arcmin)').setBackground(sizeColor).setFontSize(10).setFontWeight('bold').setFontColor('#434343').setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange('E4').setValue('Width').setBackground(sizeColor).setFontColor('#434343').setFontSize(10).setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
  sheet.getRange('F4').setValue('Height').setBackground(sizeColor).setFontColor('#434343').setFontSize(10).setHorizontalAlignment('center').setVerticalAlignment('bottom').setBorder(true, true, true, true, true, true, borderColor, SpreadsheetApp.BorderStyle.SOLID);
}
/* ===== RECOLOR — Object Database (HPC reactive) ===== */
function recolorObjectDatabase_(sh) {
  if (!sh) return;

  const hpc        = getHPC_Global_();
  const titleBg    = hpcShade(hpc, 80);
  const objectsBg  = hpcShade(hpc, 45);
  const emissionBg = hpcShade(hpc, 30);
  const transitBg  = hpcShade(hpc, 15);
  const border     = hpcShade(hpc, 40);

  // Title band (A1:Z1)
  sh.getRange(1, 1, 1, 26)
    .setBackground(titleBg)
    .setFontColor('#FFFFFF')
    .setBorder(true, true, true, true, true, true, border, SpreadsheetApp.BorderStyle.SOLID);

  // Major section headers
  sh.getRange('A2:H2').setBackground(objectsBg)
    .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);
  // Emission mini-headers (vertical) + band headers
  sh.getRange('I2:I4')                       // Surface Magnitude (vertical)
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID)
    .setTextRotation(90)
    .setVerticalAlignment('middle');

  sh.getRange('J2:M2')                        // Ha/OIII/SII/Broadband
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);

  sh.getRange('N2:N4')                        // Exposure Strategy (vertical)
    .setBackground(emissionBg)
    .setFontColor('#434343')
    .setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID)
    .setTextRotation(90)
    .setVerticalAlignment('middle');
    sh.getRange('O2:Z2').setBackground(transitBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);

  // Column headers
  ['A3:A4','B3:B4','C3:C4','D3:D4','G3:G4','H3:H4','E3:F3','E4','F4']
    .forEach(r => sh.getRange(r).setBackground(objectsBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID));

  ['J3:J4','K3:K4','L3:L4','M3:M4']
    .forEach(r => sh.getRange(r).setBackground(emissionBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID));

  for (let c = 15; c <= 26; c++) {
    sh.getRange(3, c, 2, 1).setBackground(transitBg)
      .setFontColor('#434343').setBorder(true,true,true,true,true,true,border,SpreadsheetApp.BorderStyle.SOLID);
  }
}

function _createConfigSheet_(ss) {
  const sheetName = '_config';
  let sheet = ss.getSheetByName(sheetName);
  if (!sheet) {
    sheet = ss.insertSheet(sheetName);
    sheet.hideSheet();
    sheet.getRange('A1:B1').setValues([['Key', 'Value']]).setFontWeight('bold');
  }
}

function _saveApiKeys_(cseKey, cseCx, airnowKey) {
  const sh = SpreadsheetApp.getActive().getSheetByName('_config');
  const data = [
    ['CSE_KEY', cseKey],
    ['CSE_CX', cseCx],
    ['AIRNOW_KEY', airnowKey]
  ];
  sh.getRange('A2:B4').setValues(data);
}

function _loadApiKeys_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('_config');
  if (!sh) return {};
  const data = sh.getRange('A2:B4').getValues();
  const keys = {};
  data.forEach(row => {
    if (row[0]) {
      keys[row[0]] = row[1];
    }
  });
  return keys;
}

function SkyPix_AddObjects_() {
    const sh = SpreadsheetApp.getActive().getSheetByName('Object Database');
    if (!sh) {
        SpreadsheetApp.getActive().toast('Object Database sheet not found.');
        return;
    }
    const lastRow = sh.getLastRow();
    sh.insertRowsAfter(lastRow, 25);
}

function rigkit_restoreColorPicker_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Rig kit');
  if (!sh) return;

  // Count used columns (fallback: max columns)
  const width = Math.max(2, (function getActiveWidthLocal_(s){
    let c = s.getMaxColumns();
    while (c > 1 && !s.getRange(1, c, Math.min(10, s.getMaxRows()))
                   .getDisplayValues().flat().join('').trim()) c--;
    return c;
  })(sh));

  // Anchor below "Display format"
  const dispHdr = findRowWithText_(sh, 'Display format') || 16;

  // Ensure the "Rig highlight color" row exists
  let row = findRowWithText_(sh, 'Rig highlight color');
  if (!row) {
    row = dispHdr + 3;                               // after two format rows
    sh.insertRowBefore(row);
    sh.getRange(row, 1).setValue('Rig highlight color');
  }

  // Use your COLOR_PICKER list if available; otherwise a safe fallback list
  let pickerNames = [];
  if (typeof COLOR_PICKER !== 'undefined' && Array.isArray(COLOR_PICKER)) {
    pickerNames = COLOR_PICKER.map(r => r[0]);
  } else {
    pickerNames = ['Steel Blue','Blue','Deep Blue','Cyan','Light Blue','Cornflower',
                   'Green','Teal','Purple','Magenta','Red','Red Berry','Maroon',
                   'Brown','Slate','Navy','Dk Green'];
  }

  const dv = SpreadsheetApp.newDataValidation()
    .requireValueInList(pickerNames, true)
    .setAllowInvalid(true)
    .build();

  // Apply across all rig columns (B..active)
  sh.getRange(row, 2, 1, Math.max(1, width - 1)).setDataValidation(dv);
  SpreadsheetApp.getActive().toast('Rig color picker restored.');
}

/**
 * Restore Location Finder dropdown in row 9 for all rigs
 * Call this if dropdowns get erased during operations
 */
function rigkit_restoreAllLocationFinders_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Rig kit');
  if (!sh) { ss.toast('Rig kit sheet not found.'); return; }
  
  const finderDv = SpreadsheetApp.newDataValidation()
    .requireValueInList(['Retrieve 4D Location', 'Cancel'])
    .setAllowInvalid(true)
    .build();
  
  const pairs = getPairsFromHeaders_(sh);
  pairs.forEach(([cL]) => {
    sh.getRange(9, cL, 1, 2).setDataValidation(finderDv);
  });
  
  ss.toast('Location Finder dropdowns restored for all rigs.');
}

/* ========= AUTO PATCHERS: Camera Kit & Filter Kit ========= */

// Camera Kit: ensure structure, menu, and rig eligibility/colors
function camera_autoPatch_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  const width = getActiveWidth_(sh);

  // Refresh bar: Camera options
  try { writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_CAMERA); } catch (_) {}

  // Ensure Sensor Model row exists (directly under "Camera Model")
  const camModelRow = findRowWithText_(sh, 'Camera Model');
  if (camModelRow) {
    const nextLbl = (sh.getRange(camModelRow + 1, 1).getDisplayValue() || '').trim();
    if (nextLbl !== 'Sensor Model') {
      sh.insertRowsAfter(camModelRow, 1);
      sh.getRange(camModelRow + 1, 1).setValue('Sensor Model');
      if (width > 1) sh.getRange(camModelRow + 1, 2, 1, width - 1).setBackground(WARN_ORANGE);
    }
  }

  // Ensure "Acknowledge Defaults" between "Camera Highlight Color" and "Rig Eligibility"
  const hlRow  = findRowWithText_(sh, 'Camera Highlight Color');
  const eligHr = findRowWithText_(sh, 'Rig Eligibility');
  if (hlRow) {
    const hasAck = findRowWithText_(sh, 'Acknowledge Defaults');
    const wantRow = hlRow + 1; // immediately below highlight color
    const needsAck = !hasAck || !(hasAck > hlRow && (!eligHr || hasAck < eligHr));
    if (needsAck) {
      sh.insertRowsAfter(hlRow, 1);
      sh.getRange(wantRow, 1).setValue('Acknowledge Defaults');
      if (width > 1) sh.getRange(wantRow, 2, 1, width - 1).insertCheckboxes().setHorizontalAlignment('center');
      // leave one natural blank row below (do nothing)
    }
  }

  // Rebuild/refresh Rig Eligibility list and apply rig colors
  camera_rebuildRigEligibility_();
}

function camera_rebuildRigEligibility_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Camera Kit');
  if (!sh) return;

  const width = getActiveWidth_(sh);
  let hdrRow = findRowWithText_(sh, 'Rig Eligibility');
  if (!hdrRow) {
    // If missing, create a header two rows below Acknowledge Defaults (or after Sensor Model block)
    const ack = findRowWithText_(sh, 'Acknowledge Defaults') || findRowWithText_(sh, 'Sensor Model') || 12;
    const newRow = ack + 2;
    sh.insertRows(newRow, 1);
    mergeFullWidthRow_(sh, newRow);
    sh.getRange(newRow, 1).setValue('Rig Eligibility');
    hdrRow = newRow;
  }

  const start = hdrRow + 1;
  const rigData = getRigData_(); // [{name, color}, ...]
  // Clear a reasonable area before writing
  sh.getRange(start, 1, Math.max(1, rigData.length + 6), width)
    .clearContent().clearDataValidations().setBackground(null).setFontWeight('normal');

  rigData.forEach((rig, i) => {
    const r = start + i;
    leftLabel_(sh.getRange(r, 1)).setValue(rig.name);
    // One checkbox column per camera column (B..width)
    if (width > 1) sh.getRange(r, 2, 1, width - 1).insertCheckboxes().setHorizontalAlignment('center');
    // Colorize row with the rig highlight color, if any
    const hex = nameToHex_(rig.color);
    if (hex) {
      sh.getRange(r, 1, 1, width).setBackground(hex).setFontColor(hexIsDark_(hex) ? '#FFFFFF' : '#000000');
    }
  });
}

// Filter Kit: ensure refresh menu + rig eligibility stays in sync
function filter_autoPatch_() {
  const sh = SpreadsheetApp.getActive().getSheetByName('Filter Kit');
  if (!sh) return;

  // Refresh bar: Filter options
  try { writeRefreshLabel_(sh, REFRESH_NEUTRAL_BG, REFRESH_CHOICES_FILTER); } catch (_) {}

  // Rebuild rig eligibility using existing helpers/blocks
  try {
    const rigData = getRigData_();
    const blocks = getFilterBlocks_(sh); // existing helper in your code
    rebuildRigEligibility_Filter_(rigData, blocks);
  } catch (_) {}
}

/**
 * Global onEdit router (safe overlay).
 * - If a custom router SkyPix_OnEdit_ exists, we call it first.
 * - Then we invoke the Camera Kit onEdit adjuster when editing "Camera Kit".
 * This is intentionally minimal to avoid disturbing other modules.
 */
function onEdit(e) {
  try {
    // Call your existing router if present
    if (typeof SkyPix_OnEdit_ === 'function') {
      try { SkyPix_OnEdit_(e); } catch (err) {}
    }
  } catch (_) {}

  try {
    var sh = e && e.range && e.range.getSheet ? e.range.getSheet() : null;
    if (sh && sh.getName && sh.getName() === 'Camera Kit') {
      if (typeof ck_onEditYellowAdjust_ === 'function') ck_onEditYellowAdjust_(e);
    }
  } catch (_) {}
}

